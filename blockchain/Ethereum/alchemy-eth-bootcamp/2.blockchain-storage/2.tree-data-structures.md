# tree data structures

> blockchain networks use transactions to change state and keep track of user balances.

blockchains use data structures to store all changing state data.

computer science concepts always draw trees upside down.

**node** is a basic unit of a data structure

top node is known as the **parent** (root)

bottom nodes would be **children** nodes (relative to parent). (leaves)

**binary tree**

a tree is considered binary when each parent has at most two-children

`adjective` tree. 

multiple trees have different properties that will describe the tree.

a binary tree is one where the parent nodes can have at most two children.

a linked-list is also a tree but one where there's only one child per parent forming a chain more like a tree.

```js
// linked list

class LinkedListNode {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

// tree node

class TreeNode {
  constructor(data) {
    this.data = data;
    this.children = [];
  }
}

```

file systems in computers use tree structures

**tree vocabulary**

**key** actual data held inside a node

**root** the node without a parent.

**siblings** nodes under the same parent on the same level.

**subtree** isolated tree of a broader tree.

when to use a tree

- if data needs to be stored hierarchically
- efficient data structure for searching and sorting data

> recursive algorithms are used in conjuction with trees

**balanced binary search tree**

efficient to search and sort data with

properties
- binary tree
- left subtree of a node contains nodes with keys lesser than the node's key
- right subtree of a node contains nodes with keys greater than node's key.
- each subtree must be a binary search tree

these rules or properties optimize algorithm design by assuring that some data will be guaranteed to be in certain subtree path. 

> algorithmic complexities tend to stay logarithmic instead of linear.

as you increase and pack more items into trees, the searching algorithms to traverse them don't get much more complicated.

algorithmic complexity depend on the growth of the input.

because of binary search tree enforcement properties, search time always remains `O(log n)` where `n` is the number of nodes in the tree.

data structures should ideally be as close to **constant time** 

Big O notation gives a rough indicator of how an algorithm will perform in terms of an given amount of input elements.

## building a binary search tree

starts with a root node, branches to children nodes. each parent has at most 2 children. it's a search tree because the order of nodes is sorted by the value of data.

binary property
- parents should have at most 2 children.

sorting properties
1. data in children to the left of the parent should be smaller.
2. data in children to the right of the parent should be bigger.

### 1. node

a node should contain data. 

a node should contain references to the left and right children.

**goal**

- complete constructor function. store `data` inside a prop of the same name.
- null properties in left and right as this is the root node

```js
class Node {
  constructor(data) {
    this.data = data;
    this.left = null;
    this.right = null;
  }
}

const node = new Node(5);

console.log(node.data); // 5
console.log(node.left); // null
console.log(node.right); // null
```

### 2. storing the root

a tree will keep track of a reference to the root node.

**goal**

- `Tree` constructor function to store null on the root property

```js
class Tree {
  constructor() {
    this.root = null;
  }
}
```

### 3. add root

method to add nodes in the tree.

- add a root to an empty tree

assume the tree is empty for now

```js

// create a new tree and new node
const tree = new Tree();
const node = new Node(5);

// add the node to the tree using addNode
tree.addNode(node);

// the new node becomes the tree's root
console.log(tree.root.data); // 5
```

### 4. first layer

the bottom-most layer of a tree is call its leaves

if a root already exists we'll need to decide which side to add the new leaf node to

- if new node `data` is less than root data, add it to the **left**
- if new node `data` is  more than root data, add it to the **right**

```js
class Tree {
  constructor() {
    this.root = null;
  }
  addNode(node) {
    if(!this.root) {
      this.root = node;
    } else {
      if (node.data > this.root.data) {
        this.root.right = node;
      }
      this.root.left = node;
    }
  }
}

const tree = new Tree();
const node1 = new Node(5);
const node2 = new Node(3);
const node3 = new Node(7);

tree.addNode(node1);
tree.addNode(node2);
tree.addNode(node3);

console.log(tree.root.left.data); // 3
console.log(tree.root.right.data); // 7
```

### 5. many layers

adding nodes can work for many layers of the tree with iterations or recursion.

**recursive solution**

write a function on `tree` that will take two arguments, parent and child.

function should add child under parent node.

if child data less than parent data, go left
- if parent already has a left node, call this function again having that left node as the parent
- if parent doesn't have a left node, set the new node as left node

if child data is greater than parent data, go right
- if parent already has a right node, call function recursively with the right node as parent.
- if parent doesn't have a right node, set new node as the new right node.

**iterative solution**

iterate until you find the point where node can be added using a `while(true)` and then `break` or `return` after adding the node.





