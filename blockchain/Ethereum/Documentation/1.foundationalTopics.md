# Foundational Topics

## **INTRO TO ETHEREUM**

### **blockchain**
public database

updated and shared across peers in a network
    
**blocks**
data and state stored in sequential order
    
**chain**
each block cryptographically references its parent
        
changing data and state in a block, changes subsequent blocks, requiring consensus of the entire network
    
**peers (nodes)**
computers that participate in consensus

ensure everyone has the same data and state

**consensus mechanism**

accomplishes distributed agreement, syncrhonization of state
    
- proof of stake
- proof of work
- proof of history
- etc
    
### issues with consensus across multiple distributed peers

**1. network latency**

**2. dishonest behavior**
can cause different blocks to be at the same position near the head of the chain
            
fork-choice algorithm selects canonical set of blocks during these issues

fork chooses blocks from the heaviest chain, heavy according to the # of validators that have endorsed those blocks

system of rewards (*minting*) and penalties (*slashing*) is implemented to incentivize participants to be honest
    
### **ethereum**

blockchain with a computer (evm) embedded to it

allows to build apps that are
- decentralized
- permissionless
- censorship-resistant
        
canonical computer
- EVM ethereum virtual machine
        
nodes (peers) participating in the ethereum network, agree (come to consensus) about the state of this canonical computer

every node keeps a copy of the state of the EVM

any node can broadcast a request to the network to change the state of the EVM

nodes validate the request, and execute the computation the request represents

computation changes the state of the EVM

**transaction requests**
requests for computation
        
> record of transactions and the EVM present state is stored on the blockchain

cryptography ensures 
- tamper proof records
- transactions are signed and executed with appropiate permissions (key-pairs)
    
### **smart contracts**

developers upload programs into EVM state,

users make requests to execute these programs with varying parameters

## **INTRO TO ETHER**

### **cryptocurrency**

medium of exchange secured by a blockchain ledger

**medium of exchange**
payment accepted for goods and services
        
blockchain allows participants to make transactions on a ledger without relying on a third party (middlemen)
    
### **ether (ETH)**

native cryptocurrency of ethereum

allows a market for computation

incentivizes nodes to verify and execute computation, and provide computational resources to carrie them in return of ETH.

node that broadcasts a transaction request must send an ETH fee for the computation they want to execute (represented as gas).

amount of eth paid represents the time it took to execute the computation.

prevents participants from clogging the network with infinite computation or resource-intensive scripts
        
**usecases of eth**

- rewards validators for honestly verifying the state of blockchain
- it is staked by validators to prevent dishonest behavior
- it is payed to validators for executing computations
- used to weight votes, to resolve issues with consensus (heaviest chain wins)
- allows developers to create decentralized applications which share a pool of computing power

computing power of the EVM is finite to prevent spamming the EVM or congesting the network on purpose with infinite loops

**gas fees**
cost of using the EVM to execute arbitrary computation

**EVM**
depends on amount of computation needed and the network-wide demand for computation at the time.
        
**minting ether**

process of generating new ether on the ledger

ether is minted as a reward to validators for reaching consensus

1/8 goes to the block proposer, the remainder distributed across validators

block proposers can carry computations equal to the amount of ether they have at stake

block proposers can receive tips from transaction fees and MEV-related income

**burning ether**

ether gets destroyed (burned) in every transaction on ethereum

base fee set by the newtork based on transactional demand is the amount of eth to be destroyed
        
**denominations of ether**

***wei***  
10^-18  
smallest possible amount of ether  
technical implementations  
                
***gwei giga-wei***  
10^-9  
human-readable gas fee  
            
***transferring ether***

**value field**
defines the amount of ether to be transferred (wei) from sender to recipient

 value field is in every transaction
            
if the recipient is a smart contract, the ether may be used to pay execution of code stored in the contract

**querying ether**

requesting to read the balance of any account via balance field

**balance field**
ether holdings in wei of an account
        
## **INTRO TO DAPPS**

### **dapp**

backend code running on a blockchain

front end and user interfaces 

written in any language

frontend can be hosted on decentralized storage (IPFS)

**characteristics of a dapp**

- **decentralized**
- **deterministic**
perform the same function irrespective of the execution environment
- **turing complete**
perform any action given the required resources
- **isolated**
EVM is isolated from the core blockchain
            
**smart contracts**  
backend   
 business logic of a dapp  

**benefits of dapps**

- **zero downtime**
the network is always online, available to participants 24/7
- **privacy**
real-world identity isn't needed to deploy or interact
- **censorship resistance**
no one can block users from interacting or deploying to the network
- **data integrity**
immutability, indisputable (cryptography)
- **trustless computation**
computation will execute no matter what
            
**drawbacks of dapps**
- **maintenance**
smart contracts can't be modified 
- **performance overhead**
scaling is hard as a tradeoff of security, integrity, transparency and reliability
- **network congestion**
low TPS 
- **user experience**
average user might find it too complex to interact with the blockchain
- **centralization**
to avoid a bad UX, centralizing components of a dapp is common
            
**tools for creating dapps**
- [scaffold ETH](https://github.com/austintgriffith/scaffold-eth)
                
- [eth app](https://github.com/paulrberg/create-eth-app)
                
- [FOSS tool for dapp frontends from ABI](https://oneclickdapp.com/)
                
- [etherflow](https://etherflow.quiknode.io/)
                
    
### **dapp architecture**

**web 2.0 application**

- front-end (JS, HTML, CSS)
- back-end (node.js, Python, Java, Go)
- database

**web 3.0 application**

#### **FRONT-END**

(JS, HTML, CSS)  
defines UI logic, but also interacts with the application logic from smart contracts

#### **BACK-END**  

**smart contracts**  
program running on the EVM  
written in high-level languages (solidity, vyper, rust, javascript)  

**ethereum virtual machine**    
execute logic defined in smart contracts  
processes state changes in the ledger  

**ethereum blockchain**  
global state machine  
state changes are governed by the consensus the peers follow in the network  

**node infrastructure**   
two ways to broadcast a transaction to the blockchain    
1. setting up your own node that runs the blockchain software, keeping track of all state changes in the ledger  
2. use nodes provided by thirt-parties (infura, alchemy, quicknode)  

**providers**  
nodes that connect to the blockchain    
all providers implement JSON-RPC specification  
uniform set of methods to interact with the blockchain (read and write)  

**JSON-RPC**  
stateless lightweight remote procedure call  
defines data structures and rules to process them  

**transport-agnostic**  
concepts compatible with sockets, HTTP or different   message-passing environments   
 
reading the blockchain data is free  

writting on the blockchain is called a transaction,requires a transaction fee  

**signer**  
tool to handle key management and transaction signing  
whenever the front-end needs to sign a transaction, it calls the signer (metamask) 

**decentralized storage**  
**IPFS**  
distributed file system for storing and accessing distributed data

file coin, incentive layer

can host front-ends in a decentralized way

**Swarm**
            
querying the blockchain

to read data from smart contracts

**web3.js**
library to query and listen for smart contract events

allows to listen to specific events and trigger callbacks 
                
**the graph**
off-chain indexing solution

queries data from ethereum and other blockchains

allows to define what to listen
- contracts
- events
- functions

allows to define how to transform incoming events to entities front-end will consume

uses graphQL query language  
more expressive than REST APIs
                    
scaling solutions
- layer 2
- optimistic rollups
- zkrollups
- sidechains

## **WEB2 | WEB3**

### **web2**

internet dominated and owned by companies that exchange services for personal data

censorship is allowed at discretion 

payments can be denied

centralized servers can have downtime

### **web3**

decentralized apps that run on the blockchain, companies aren't entitled to monetize their user's personal data

censorship resistant

can't deny payments

ethereum has zero down-time

limitations
- **scalability**
low TPS
- **UX**
extra steps and knowledge from the end-user to interact 
- **accessibility**
lack of integration in modern browsers
- **cost**
expensive to use
        
### **centralized systems**

low network diameter, propagation is handled by central authority, server, entity

higher performance due to not sharing computational resources globally

- source of truth: central authority
- single point of failure: central authority
- censorship prone by central authority

participating in the network is decided by central authority

### **decentralized systems**

information broadcast may take longer to reach all peers across the globe

lower performance, more complex, more computational resources needed

no single point of failure

- coordination is difficult  
network fracturing (forks) with disagreement
        
- censorship resistant  
no way to stop propagating the change of state once one node broadcasts it and a validator processes the computation

## **ACCOUNTS**

### **externally owned account EOA**

- controlled by private keys
- costs nothing to create it
- can initiate transactions
- transactions between EOAs can only be eth/token transfers
        
**cryptographic pair (public, private)**
help verify a transaction was signed by the sender 
            
private key signs transactions broadcasted to the network

grants custody (access) to funds stored on the ethereum ledger

**private**

64 hex characters

can be encrypted with a password

A sign a message with the private key, this action returns a signature 

others can derived the public key of A from the signature, proving that the message is indeed from both the same public and private key pair

**public**

derived from the private key using elliptic curve digital signature algorithm

20 last bytes of the keccak-256 hash of the public key becomes a public address

new public keys can be derived from the private

### **contract account**

smart contract deployed to the network,

there's a cost to create it as network storage is needed to store the contract(program, script, code)

transactions from an EOA can trigger the program to execute and change the state of the EVM

don't have private keys, controlled by business logic of the code.

42 hexadecimal address given when a contract is deployed address comes from the creator's address and the nonce
    
both accounts can
- receive hold and send eth and tokens
- interact with deployed contracts
    
### **account properties**

**nonce**

counter indicating # of tx sent from the account

counter ensures a tx is processed only once

in a contract account, it represents the number of contracts created by the contract account

**balance**

number of wei owned by the address

10**18 wei per 1 ETH

**codeHash**

refers to the code of a contract account

code fragments (programs, smart contracts, scripts) are stored on the contract account

the code can be called by accounts

it can't be changed

EOA codeHash is a hash of an empty string

**storageRoot**

256-bit hash of the root node of a merkle patricia trie

encodes contents of the account (mapping between 256-bit integer values)

trie encodes the hash of the storage contents of an account
    
### **validator keys**

BLS are used to identify validators

efficiently aggregated to reduce bandwidth required to reach consensus on the network

without BLS, the minimum stake for a validator would be higher

## **TRANSACTIONS**

cryptographically signed instructions from accounts

an account will initiate a transaction to update the state of the network

initiated by an EOA

any node can broadcast a request for a transaction to be executed on the EVM

a validator executes the transaction and propagates the resulting state change to the rest of the network

### **submitted transaction**

**recipient**
receiving address

if EOA, the tx is a transfer

if contract, the tx is an instruction to execute the code in a smart contract

**signature**
identifier of the sender

generated when the private key signs and verifies the transaction is authorized to be broadcasted

**nonce**

sequencially incrementing counter

\# of tx of an account

**value**
amount of ETH to transfer (in wei)

**data**
optional field to include arbitrary data

**gasLimit**
max amount of gas units to be consumed during the transaction

**maxPriorityFeePerGas**
max amount of gas to be included as tip 

**maxFeePerGas**
max amount of gas willing to pay for the transaction
    
### **gas**

references the computation required to process a transaction

simple transfer transactions require 21,000 units of gas

**Bob sends Alice 1 ETH**

`baseFeePerGass`: 190 gwei  
`maxPriorityFeePerGas`: 10 gwei   

(190 + 10) * 21000 = 4,200,000 gwei or 0.0042 ETH

baseFee is burned

alidator keeps the tip 

### **transaction obejct** 
```js
{
  from: "0xEA674fdDe714fd979de3EdF0F56AA9716B898ec8",
  to: "0xac03bb73b6a9e108530aff4df5077c2b3d481e5a",
  gasLimit: "21000",
  maxFeePerGas: "300",
  maxPriorityFeePerGas: "10",
  nonce: "0",
  value: "10000000000"
}
```
    
an ethereum client will handle the signing process

### **JSON-RPC call (request)**

```js
{
  "id": 2,
  "jsonrpc": "2.0",
  "method": "account_signTransaction",
  "params": [
    {
      "from": "0x1923f626bb8dc025849e00f99c25fe2b2f7fb0db",
      "gas": "0x55555",
      "maxFeePerGas": "0x1234",
      "maxPriorityFeePerGas": "0x1234",
      "input": "0xabcd",
      "nonce": "0x0",
      "to": "0x07a565b7ed7d7a678680a4c162885bedbb695fe0",
      "value": "0x1234"
    }
  ]
}
```
    
### **JSON-RPC response**

```js
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "raw": "0xf88380018203339407a565b7ed7d7a678680a4c162885bedbb695fe080a44401a6e4000000000000000000000000000000000000000000000000000000000000001226a0223a7c9bcf5531c99be5ea7082183816eb20cfe0bbc322e97cc5c7f71ab8b20ea02aadee6b34b45bb15bc42d9c09de4a6754e7000908da72d48cc7704971491663",
    "tx": {
        "nonce": "0x0",
        "maxFeePerGas": "0x1234",
        "maxPriorityFeePerGas": "0x1234",
        "gas": "0x55555",
        "to": "0x07a565b7ed7d7a678680a4c162885bedbb695fe0",
        "value": "0x1234",
        "input": "0xabcd",
        "v": "0x26",
        "r": "0x223a7c9bcf5531c99be5ea7082183816eb20cfe0bbc322e97cc5c7f71ab8b20e",
        "s": "0x2aadee6b34b45bb15bc42d9c09de4a6754e7000908da72d48cc7704971491663",
        "hash": "0xeba2df809e7a612a0a0d444ccfa5c839624bdc00dd29e3340d46df3870f8a30e"
    }
  }
}
```
**raw property**

signed transaction in RLP (recursive length prefix) encoded form

the tx is the signed transaction in JSON form
        
with signature hash, the transaction is cryptographically proven to come from the sender

**data field**

contracts are written in solidity and interpret their data field in accordance with the application binary interface (ABI).

first 4 bytes defines which function to call  
uses the hash of the function's name and arguments
            
rest of the calldata is the arguments

### **type of transactions**
- **regular**
- **contract deployment**  
don't have "to": address  
data field is used for the contract code  
- **execution of a contract**  
tx interacts with a deployed contract  
"to": is the contract address  
        
### **transaction lifecycle**

once transaction is sent, cryptography generates a tx hash

tx is broadcast to the network included in a pool of txs

a validator must pick the tx and include it in a block to verify it and consider it successful

as time passes, transaction updates from 'justified' to 'finalized' 
    
### **typed transaction envelope**

original format for transactions, each field RLP-encoded

`RLP([nonce, gasPrice, gasLimit, to, value, data, v, r, s])`

ethereum now supports multiple types of transactions

**EIP-2718 typed transaction envelope**
defines a transaction type 
        
a new standard where transactions are interpreted as

- **TransactionType**
number between 0 and 0x7f for a total of 128 tx types
                     
|| 
                
- **TransactionPayload**
arbitrary byte array defined by the transactionType
                
## **BLOCKS**

batches of txs with a hash of the previous block linking blocks together in a chain

hashes are cryptographically derived from the block data preventing fraud, one change in a a block, would invalidate the following blocks as subsequent hashes would change

blocks ensure participants maintain a syncrhonized state and agree on precise history of txs

txs are batched into blocks

multiple txs are agreed on and their state updates synched all at once

blocks are strictly ordered

every new block references its parent block

txs within blocks are strictly ordered as well

once a block is put together by a validator, is propagated throughout the entire network

**the block assembly process is defined by the consensus mechanism**

- proof of work
- proof of stake

validating nodes need a min amount of ETH (32) into a deposit contract as collateral to lose for dishonest actions

in every slot, a validator is randomly selected to be a block proposer, execute all transactions in it and updates the state of the blockchain

if validators hear two conflicting blocks for the same slot, the fork-choice algorithm picks the block supported by the most staked ETH
        
### **anatomy of a block**

**slot**  
the slot the block belongs to

**proposer_index**  
id of validator proposing the block

**parent_root**  
hash of preceding block

**state_root**  
root hash of the state object

**body**  
object containing properties
  - ***randao_reveal***  
value used to select next block proposer
  - ***eth1_data***  
information about deposit contract
  - ***graffiti***  
arbitrary data used to tag blocks
  - ***proposer_slashings***  
list of validators to be slashed
  - ***attester_slashings***  
list of validators to be slashed
  - ***attestations***  
list of attestations in favor of the current block  
contains
    - ***aggregation_bits***  
list of which validators participated in the attestation
    - ***data***  
container with subfields  
contains
      - ***slot***     
slot the attestation relates to
      - ***index***   
indices for attesting validators
      - ***beacon_block_root***  
the root hash of the beacon block
      - ***source***  
the last justified checkpoint
      - ***target***   
latest epoch boundary block
      - ***signature***  
aggregate signature of all attesting validators.  
executing transactions in execution_payload updates the global state.  
all clients re-execute transactions in the execution_payload to ensure new state matches the new block state_root field.  
execution_payload is an object with several fields(properties)  
**execution_payload_header**  
contains summary about the execution data  
contains
        - ***parent_hash***
hash of the parent block
        - ***fee_recipient***
account address for paying transactions fees to
        - ***state_root***
root hash for global state after applying changes
        - ***receipts_root***
hash of the transaction receipts trie
        - ***logs_bloom***
data structure containing event logs
        - ***prev_randao***
value used in random validator selection
        - ***block_number***
number of current block
        - ***gas_limit***
max gas allowed in the block
        - ***gas_used***
the actual amount of gas used in the block
        - ***timestamp***
block time
        - ***extra_data***
arbitrary additional data as raw bytes
        - ***base_fee_per_gas***
base fee value
        - ***block_hash***
hash of execution block
        - ***transactions_root***
root hash of the transactions in the payload
                
                
### **block time**

time separating blocks

time is divided up into twelve second units called slots

a single validator is selected to propose a block in each slot

the block time is 12s when all validators are online

### **block size**

each block has a target size of 15 million gas

size of blocks increase or decrease related to netowkr demands

up (block limit 30 million 2x)
down ()
        
total gas expended by all txts < block gas limit

ensures blocks can't be arbitrarily large
            
speed and network requirements would increase if the block size could be arbitrarily large
        
## **ETHEREUM VIRTUAL MACHINE (EVM)**

EVM instantiation exist as one single entity maintained by multiple connected computers running the ethereum client

the protocol's purpose is to keep the continuous, uninterrupted and immutable operation of the EVM (the state machine)

its the (runtime) environment for accounts and smart contracts

the EVM defines the rules for computing a new valid state from block to block

### **cryptocurency ledgers**

distributed using a peer to peer network

secured using asymmetric cryptography

ledger maintains a record of activity, which must adhere to a set of rules defined by the consensus mechanism
        
ethereum is a distributed state machine (VM)

### **ethereum state**
  
data structure that holds

- **account storage**  
accounts  
balances

- **machine state(volatile)**  
can be updated(modified) from block to block according to a set of rules.    
abritrary immutable machine code is executed to perform a state update.  
program counter(PC)    
gas available    
stack   
memory    
            
- **virtual ROM**  
EVM code (immutable)

**modified merkle patricia trie**  
keeps all accounts linked by hashes to be reduced to a single root hash stored on the blockchain

### **mathematical function**

given an input, produces a deterministic output

**deterministic**  
will always produce the same output from a given input (condition, initial state)
    
### **deterministic turing machine**  

model of computation  

succesive states of the machine and the operations to be performed are determined by the preceding state

### **ethereum has a state transition function**

`Y(S, T) = S'`

`S`  
old valid state

`T`  
new set of valid transactions

`Y(S, T)`  
the ethereum state transition function produces S'

`S'`  
new valid state     
    
### **transactions**

cryptographically signed instructions from accounts

two types
- **message calls**
- **contract creation**  
creates a new contract account containing a compiled contract bytecode  
when an account makes a messsage call to the contract, the bytecode executes.

### **EVM instructions**

**stack machine**

computer processor (virtual machine)
        
**stack**

abstract data type that serves as a collection of elements to push and pop

analogy, a stack of elements stacking vertically on top of each other, 

push (adding) pop (removing) modifies elements on the top of the stack (the end)

LIFO (last-in first-out)
            
linear sequential collection

**stack overflow**
no more space left to add elements, the stack is full.
            
EVM executes as a stack machine with a depth of 1024 items.

***each item is 256-bit word***  
- ease of use with 256-bit cryptography  
Keccak-256 hashes  
secp256k1 signatures'  
            
during execution (run-time), the EVM maintains a transient memory (word-addressed byte array).

doesn't not persist between transactions

contracts have a merkle patricia storage trie (word-addressable word array) associated with the account and part of global state

compiled contract bytecode executes as a number of EVM opcodes

opcodes perform stack operations like `XOR` `AND` `ADD` `SUB`

EVM implements blockchain-specific stack operations
- ADDRESS
- BALANCE
- BLOCKHASH
    
### **EVM implementations**

must adhere to the specification described in the ethereum yellowpaper
    
### **opcodes**

**EVM**

stack-based, big-endian VM

256-bits word size

smart contracts run EVM bytecode when receiving a transaction, allowing them to perform arbitrary computation

tx carry a payload of 0 or more bytes of data

defines the type of interaction with the contract

each opcode is encoded as one byte, except `PUSH` opcodes

opcodes work at the end (top) of the stack

**contract creation**

data payload to create a contract is bytecode that runs the contract constructor,

**contract constructor**
sets up the initial contract state, and returns the final contract bytecode

constructos are not present in the contract once deployed

contracts expose ABI (list of uniformed supported methods to interact with a contract)

a user submits a tx with any # of wei, and a data payload formatted to ABI specification

**data handling** 

***call data***

data associated with a tx

contains a 4-byte method identifier

followed by serialized arguments

***stack***

EVM maintains a stack of uint256 to hold local variables, function call arguments and return addresses

***memory***

array of uint8 used to hold transient data while contract is executing
            
***storage***

persistent associative map with uint256 as keys and uint256 as values
            
contract fields and mappings are stored 
            
## **GAS**

unit that measures the # of computational effort to execute operations on the Ethereum network

each tx requires computational resources to execute

each tx requires a fee

1 giga-wei   
0.000000001ETH  
10**-9  
1,000,000,000 wei  

1 gwei  
9 decimals to the right  
0.000000001  
\# 0s === # decimals - 1  
8 - #0s gwei = # total 0s  
 
10 gwei  
8 decimals  
0.00000001 ETH   

100 gwei  
7 decimals  
0.0000001 ETH  

1,000 gwei  
6 decimals  
0.000001 ETH  

10,000 gwei  
5 decimals  
0.00001 ETH  

100,000 gwei  
4 decimals   
0.0001 ETH  

1,000,000 gwei  
3 decimals  
0.001 ETH  

10,000,000  
2 decimals  
0.01 ETH  

100,000,000  
1 decimals  
0.1 ETH  

1,000,000,000  
0 decimal  
1 ETH  

1 wei  
0.000000000000000001ETH  
10**-18  

### **prior to london fork**

1 ETH transfer

21,000 units as gas limit

gas price 200gwei

gas units * gas price per unit

21,000 * 200 = 4,200,000 gwei 0.0042 ETH

blocks were fixed-sized

### **after london upgrade**

1 ETH transfer

21,000 units 

base fee 10gwei

extra tip of 2 gwei

gas units * (base fee + tip)

21,000 * (10 + 2) = 252,000 gwei 0.000252 ETH

variable-sized blocks were introduced

15,000,000 gas units target size

2x (30,000,000) gas units block limit size

**tatonnement**   
process in which the protocol achieves 15 million gas units equilibrium across blocks on average
        
if block size is larger than target block size, base fee is **increased**

if block size smaller than target size, base fee is **decreased**

change in base fee proportional to how far the current block size is from target size
    
### **base fee**

base fee acts as a reserve price

base fee is calculated based by blocks before it

base fee is burned when a block is minted

formula that compares the size of the previous block (# of gas used by al txs) with the target size

12.5% max increase if target block size is exceeded every block that exceeds target size (30 Million gas units consumed)

### **priority fee**

incentivizes miners to include a transaction in the block
    
### **max fee**

maxFeePerGas

must be more than the sum of base fee and tip

the sender is refunded the difference between max and (base + tip)
    
the london upgrade improved the fee market to optimize user experience


wallets can automatically suggest a baseFee + tip based on the model introduced in the fork, where each block baseFee is determined by the previous block, making it more predictable to know the baseFee for next block

### **EIP-1559**

makes gas fees more predictable

### **gas fees purpose**

keeps the ethereum network secure

executing computation requires a fee,

this prevents spamming the network to consume all the shared global resources (infinite loops, resource-intensive computation)

unit of computation is called gas

### **gas limit**

max amount of gas willing to be consumed (spent) on a tx

some computational work require a higher gas limit than a simple transfer (21,000)

setting a lower gas units limit than the computation requires will cause the validator to use the resources (gas units) to perform the computation, they won't be enough to complete the work, so it fails, yet the gas is consumed

### **common tasks on ethereum**

storing or manipulating data  
transfers
    
a contract can execute a task with multiple calculations in one single message call

the more complex a task, the more computational steps it needs to take, each tx takes up more space in a limited size block

scalability upgrades are solutions to address gas fee issues that will enable the platform to process much higher tps

## **NODES AND CLIENTS**

ethereum is a distributed network of nodes 
    
### **nodes**

computers running software that can verify blocks and perform computations on the EVM

### **client**

software application used by nodes to verify blocks (secure the network through cryptography) and perform computations (zero-down EVM runtime)

clients can be made with multiple programming languages(go, rust) (client diversity)

**execution client**

execution engine, former eth1 client

listens to tx broadcasted in the network

executes them in the EVM and holds latest state and database of all ethereum data

**execution layer (EVM)**

- ***geth (go)***  
goEthereum  
most widespread
- ***nethermind (c#, .NET)***

- ***besu (java)***
hyperledger  
enterprise-grade  
public and permissioned networks  
- ***erigon (go)***
formerly turbo-geth  
fork of geth  
optimized speed and disk-space efficiency  
- ***akula (rust)***
- ***openEthereum(deprecated)***

**consensus client**

beacon node , former eth2 client

implements proof of stake consensus algorithm

enables the network to agree on validated data from the execution client

**consensus layer = beacon chain**

- ***lighthouse (rust)**  
fastest sync strategy (snap)  
save disk usage and network bandwidth  
                
- ***lodestar(typescript)**

- ***nimbus(nim)**  
resource efficiency oriented
- ***prysm(go)**

- ***teku(java)**  
one of original beacon chain genesis clients
    
**synchronization strategies**

a client needs to sync with latest network state by downloading data from peers, cryptographically verifying their integrity and building a local blockchain databease of the state

can optimize synchronization time

how quickly it can get the most up-to-date information on ethereum's state
            
**full**  
downloads all blocks (headers, transactions and receipts)

generates state incrementally by executing every block from genesis
            
**fast**   
download all blocks, verifies headers, downloads the state and verifies it against the headers
            
**light**  
downloads block headers, data and verifies some randomly, only syncs the tip of the chain from trusted checkpoint

**snap**   
latest approach

dynamic snapshots retrieves all account and storage data without downloading intermediate trie nodes, then reconstructs the trie locally
            
**snap without serving**

**optimistic sync**  
post-merge strategy

opt-in and backwards compatible

the engine can optimistically import beacon blocks without fully verifying them, finding the latest head and start syncing the chain with the methods designed in the sync strategy

after client has caught up, then the validity is confirmed
            
**checkpoint**  
weak subjectivity sync

enables syncing the chain from a recent weak subjectivity checkpoint instead of genesis

### **before the merge** 

eth1 chain proof-of-work chain, deprecated via difficulty bomb

in charge of both execution and consensus using one single client

one client provided both execution runtime environment and consensus algorithm to verify blocks via POW
    
eth2 the beacon chain

beacon chain has been running separately since 2020 eth2, copying eth1 state (transactions, apps, contracts, balances) into it, introducing POS to the consensus layer, execution was still carried via POW

### **after the merge**

both execution and consensus clients must be run together

execution and consensus layer work together to verify state

no more eth1 or eth2, only one merged chain

**encapsulated complexity**
modular design with various software components
    
**client diversity**

both execution and consensus clients exist in different languages

achieves decentralization this way to not depend in a single client

a specification must be adhered
    
**node trackers**
- https://etherscan.io/nodetracker
- https://ethernodes.org/
    
**node types**

**full**  

stores full blockchain data   

periodiacally pruned to not store all state dating back to 
genesis   

participates in block validation (verifies blocks and 
state)   

all states can be derived from a full node (very old state 
needs to request an archive node)   

provides data on request   
        
**light** 

only download block headers containing summary of the content of a block

can verify the data they receive with the state roots in the block headers

enables users to participate in the network without powerful hardware or high bandwidth 

provides same functionality as a full node, except consensus participation

light nodes eventually will run on phones or embedded devices

geth has a light sync option

light nodes rely on full nodes serving data

some full nodes opt out of serving light nodes, light nodes might fail to find peers

lightnode implementations is widely unsupported as of now

area with room to grow

**archive**

stores everything kept in a full node

builds archive with historical states

block explorers, wallet vendors and chain analytics use data stored in historical states (units of terabytes)

full node can build historical states on demand

all nodes are pruned except archival
    
### **running nodes**

enables to use ethereum privately, self-sufficiently and trustlessly

ability to verify data with your own client

addresses and balances aren't shared with random nodes

**RPC-importing**

using your own node to connect to ethereum with wallet software

custom RPC endpoints avoid centralized providers

IPC inter-process communications

connect to custom node
    
### **setting up a node**

choose client implementation (of both execution and consensus clients)

- environment (hardware, system)

parameters for client settings

**local setup**

trustless and sovereign

best for the ecosystem

**cloud setup**

high server uptime and static public IP addresses

dedicated or virtual server is easy

trust in third-party could lead to a single point of failure

GUI or terminal can install the clients

after node syncs, is ready to be used

**system requirements**

blockchain is input/output intensive requiring lots of space

SSD are better tha HDD

***min***
- CPU 2+ cores
- 8GB RAM
- 700 GB disk space
- 10+ Mbit/s bandwidth
            
***recommended***
- CPU 4+ cores
- 16 GB RAM
- SSD 1+ TB disk space
- 25+ Mbit/s bandwidth
            
**plug and play**
preconfigured machines ready to connect and run
        
**single-board computer**

ARM architecture like Raspberry Pi

easy-to-run images of clients
        
**spinning up the node**
            
client setup can be done via 
- automated launchers
- manually
            
- DappNode
- eth-docker
- stereum
- nicenode
        
downloading pre-built binary means trusting whoever built it didn't swap the executable for a malicious one

developers sign released binaries with PGP keys to verify you are running the software they created

**GnuPG**
implementation to verify PGP keys
        
developers can verify the hahs of the downloaded software matches the one provided by official developers   

run the hash function on the donwloaded software and compare to the one from the release page
        
**client setup**
- *sync mode*
method of downloading and validating blockchain data
- *prunning of different kinds of old data*
- *choosing a network to connect to*  
mainnet  
testnets  
- enabling HTTP endpoint for RPC or websockets  

executing and consensus clients communicate via authenticated endpoint 
- engine API
- JSON RPC

the execution client generates a jwtsecret at a known path

both clients must know this path to authenticate local RPC connection between them

`ex` client must define a listening port for authenticated APIs
        
consensus client must have port configuration to establish local RPC connection to the ex client

`con` client needs the path to the ex client's jwt-secret in order to authenticate the RPC connection

`ex` clients offer RPC API endpoints to submit transactions, interact with or deploy contracts.

- manually calling them with the suitable protocol (Curl)
attaching a provided console

- implementing them in apps using web3 libraries  
web3.py  
ethers  
            
**beacon API**

used to check status of the consensus client

download blocks and consensus data using tools like Curl
        
default port is 8545

access to the RPC interface can be extended through edge layer APIs or web server applications (Nginx) and connecting them to the clients local address and port

### **client diversity**

**bugs**

clients suffering a shared issue is small if client architecture is diverse
        
**resilience to attacks**

not all clients can be exploited if they have different architectures
        
**proof-of-stake finality** 

a bug in con client with over 33% of eth nodes could prevent from finalizing transactions

can't trust txs won't be reverted or changed
            
using a minority client improves the health of the and resilience of the network

**execution clients**
- geth 83.7%
- open ethereum 8.1%
- erigon 5.7%
- nethermind 1.5%
- besu 0.8%
- teth 0.1%
- coregeth 0.1%

**consensus clients**
- prysm 66.17%
- lighthouse 18.7%
- teku 9.04%
- nimbus 5.21%
- grandine 0.73%
- others 0.15%
        
### **nodes as a service**

node service providers run node clients

provide API key to read and write on the blockchain

running own node can be expensive
- storage
- bandwidth

handle common node operator tasks
- spinning up nodes
- upgrading nodes
- ensure state consistency

**node providers**

- **alchemy**  
300M compute units per month  
multichain  
70% of ethereum transaction volume  
webhook alerts   
NFT API   
dashboard  

- **ankr**

- **blockdaemon** 

- **chainstack**

- **datahub**

- **getblock**

- **infstones**

- **infura**

- **kaleido**

- **moralis**

- **nownodes**

- **pocket network**  
decentralized RPC protocol and marketplace  
public endpoints  

- **quicknode**

- **rivet**

- **senseinode**

- **settlemint**

- **watchdata**

- **ZMOK**

## **NETWORKS**

different ethereum environments 

ethereum is a protocol, multiple independent networks can be buit adhering to the protocol, without interacting with each other

### **public networks**

anyone can
- read or write txs
- validate txs being executed
        
**ethereum mainnet**
production primary ethereum blockchain
        
**ethereum testnets**  
useful for
- protocol testing
- smart contract testing
            
proof-of-authority consensus mechanism

small # of nodes are chosen to validate txs and create new blocks

- **goerli**  
long-term stable testnet  
- **Sepolia**  
not going to be maintained   
- **Ropsten**  
deprecated
- **rinkeby**  
deprecated  
POA for nodes running an old geth client  
- **kovan**  
deprecated  
POA for nodes running openEthereum clients      
- **layer 2 testnets**  
layer 2 collective term to describe ethereum scaling solutions  
separate blockchain that extends ethereum and inherits the security of it  
***arbitrum rinkeby***   
***optimistic kovan*** 
    
### **private networks**
        similar to creating a local server 
    
### **consortium networks**
        consensus controlled by a pre-defined set of trusted nodes

## **CONSENSUS MECHANISMS**

complete stack of ideas, protocols and incentives that enable distributed nodes to agree on the state of a blockchain

consensus means a general agreement has been reached

reaching consensus means at least 66% of nodes agree on global state of the network

crypto-economic incentive layer (rewards and penalties applied to stakers)

protocol that governs how validators are selected to propose blocks

in the case theres multiple blocks in the same position near the head of the chain, a fork-choice algorithm chooses the chain validated by most of the nodes

**sybil resistance and chain selection**

proof of anything are sybil resistance mechanisms and block author selectors not consensus protocols

a method to decide who is the author of the latest block

**fork-choice algortihm (chain selection)**
enables nodes to pick a single correct block at the head of the chain where multiple blocks are in the same position

determined by chain with the greatest weight of attestations

POW determines the greatest weighted chain by total cumulative POW difficulty

POS determines the greatest weighted chain by total cumulative sum of validator nodes
        
sybil resistance measures how a protocol does agaisnt a sybil attack

**sybil attack**  
one or a group of users pretend to be many users

these sybil resistance mechanisms like POW and POS protect against bad actors by requiring huge computational power or huge collateral at stake, to attempt to corrupt the network

### **proof of work**

**block creation**  
validators create blocks  
validator randomly selected in each slot to be a block proposer.  
consensus client requests a bundle of transactions as execution payload from the execution client.  

execution payload is wrapped in consensus data to form a block which the proposer sends to the network

this block production is rewarded with crypto

when there's conflicting blocks, *fork choice algorithm* chooses the chain with greatest weight of attestations.

**security**  
51% of the network total computational power is needed to corrupt the network
        
POW sets the difficulty and rules for the work miners do

mining is the act of adding valid blocks to the chain

the more work done, the longer the chain, the higher block number, the more certain the network can be of the current state

**POW block data**

- block difficulty
- mixHash
- nonce
        
**POW protocol of ethereum ethash**

requires miners to trial and error to find the nonce to create a block

1. a miner repeatedly put a dataset (only obtained by downloading and running the full chain) through a mathematical function

2. the dataset generates a mixHash

> difficulty determined the target for the hash

3. once the mixHash is generated other miners and clients can easily verify

even with one single different tx the mixHash would change, uncovering fraud

proof of work rules also issued new currency incentivizing miners to perform the task to find the nonce of new blocks

**ommer blocks**  
valid blocks created by the miner at the same time another miner created a canonical block

ommer blocks happened because network latency
            
**finality**

a tx has finality when its part of a block that can't be altered anymore

decentralization means multiple miners were able to submit valid work, creating a temporary fork, the fork-choice algorithm would choose the longest chain

transactions included in ommer blocks could be reversed by the fork-choice algo

finality is the time it takes to consider a tx irreversible

the more blocks mined on top of a N block, the higher the confidence that the tx in N were successul and not reverted

**energy usage**  
70 TWh/year to power ETH POW
        
mining is securing the network

computation power processes txs and produce blocks 

order of txs ensure the computation isn't performed twice, or dishonest computation is executed

mining difficulty increased as network increased expansion

average equipment wasn't going to solve computational puzzles enough to be profitable

**process of mining**

1. a user writes and signs a transaction request using private keys of an account.

2. user broadcasts the transaction request to the entire ethereum network using a node.

3. upon hearing the tx request, each node in the network adds the request to their local mempool

> **mempool**
list of tx requests that are heard, but not yet committed in a block.
            
4. a mining node aggregates multiple tx into a potential block to maximize tx fee profit while targeting block gas limit (15 million gas units spent in aggregate)

**the mining node tasks**

- verifies validity of txs   
account performing the message call (transaction request) is signing it with a valid private key  
the request is in the correct format  

- executes the code of the request altering the state of their local copy of the EVM.

- miner awards the tx fee of the entire block to their account.
                
- begins producing the certificate of legitimacy for the potential block once all message calls have been verified and executed.

- node finishes producing the certificate.

> the completed block includes a **certificate** and **checksum** of the new EVM state.

**when other nodes hear about the new block**

- verify the certificate
- executes all txs by themselves
- and verify that the checksum of their new EVM state matches the checksum of the state claimed by the block proposer.

only then other nodes will append the new block to the tail (head) of the blockchain and accept the new EVM state as canonical.

each node removes all txs in the new block from the local mempool of unfulfilled (but heard) tx requests (message calls).

new nodes in the network download blocks in sequence, initialize a local EVM copy starting blank, and then execute every transaction in every block, verifying state checksums each block.

> **don't trust, verify**

ethash was a successor of an og r&d dagger-hashimoto
        
**mining algorithms**

ethash miners try to find a nonce input using brute force computation so resulting hash is smaller than treshold determined by calculated difficulty

**dagger hashimoto**

- **dagger**
involves generating a directed acyclic graph
- **hashimoto**
adds ASIC-resistance by being I/O bound  
memory reads are the limiting factor  
                    
### **proof of stake**

gasper is the consensus mechanism used by proof of stake ethereum

**gasper**
casper friendly finality gadget

upgrades certain blocks to finalized

nodes can be confident that they are syncing to the canonical chain

**LMD-GHOST fork choice algorithm**

accumulates votes to ensure nodes can detect the most voted chain in case of conflict

these components form the consensus mechanism in proof-of-stake of ethereum

gasper is a mechanism that defines how validators       
- get rewarded or punished (dishonesty laziness)
- decide which blocks to accept and reject
- decide which fork of the chain to build on

**block creation**

done by validators staking min 32 ETH

validator chosen at random to become a block proposer

instead of needing to perform intense computational work, a locked collateral is enough to validate blocks

**security**

an attacker must destroy huge amounts of ETH to attempt to control the network.

high risk with low reward discourages dishonest nodes to defraud the rest of nodes.

**51% attack**  
attacker needs control of 51% of the staked eth to make a corrupted state, canonical

the community can mount a counter-attack (**inactivity leak**) if this happens.

honest validators can keep building in the minority chain and ignore the biggest fork that won corruptly.

**other attacks**
- **long-range attacks**  
early node participants maintain an alternative fork to release much later to their own advantage
- short-range reorgs
- bouncing and balancing attacks
- avalanche attacks

switches computational power (POW) for staked ETH (POS)
        
algo chooses a validator randomly instead of everyone competing to create blocks

finality is clearer (if 2/3 validators agree on the state is considered final).

validators explicitly stake ETH in a contract acting as collateral that gets destroyed in the case the validator behaves dishonestly (double spending) or lazily (compromising runtime).

validators responsability is to check new blocks propagated over the network are valid.

ocasionally (randomly) being selected to propose new blocks.

**benefits**  
- **energy efficient**  
no need of proof-of-work computations          
- **lower entry barrier**  
reduced hardware requirements
- **reduced centralization**  
more nodes are able to participate in the network
            
less ETH is needed to mint to incentivize participation, reducing inflation from minting 
            
economic penalties make 51% attacks exponentially costly

social recovery of an honest chain is possible even after a 51% attack.

**validators**

a user must deposit 32 ETH into the deposit contract

run  
execution consensus client  
validator  

once a validator is activated it can recieve blocks from its peers

validators must re-execute txs from the already produced blocks they receive (hear) to verify the block signature is valid

validator sends a vote (attestation) in favor of that block across the network
            
**timing of blocks is fixed** (pow determined by mining difficulty)
- 12 second slots and epochs (32 slots each)

one validator is randomly selected every slot to be a block proposer

block proposer must create the block and propagate it to all other nodes

a committee of validators is also randomly chosen every slot

votes are used to determined the validity of the block being proposed.

**finality**
when a tx in a block becomes irreversible

checkpoint blocks help with finality

the first block in an epoch is a checkpoint

validators vote for pairs of checkpoints considered to be valid
                
2/3 of validators are enough to upgrade the pair checkpoints,

the target becomes justified (the more recent of the pair) the oldest was the target in the previous epoch, upgrading to finalized

to revert a finalized block an attacker must be willing to commit losing at least 1/3 of total supplied staked ETH

mechanism allows to defend against the inactivity leak

property of a block makes it irreversible unless an attacker has destroyed 1/3 of the total staked ether

finalized blocks are certain

blocks go through a two-step upgrade procedure to become finalized

2/3 of total staked ether must have voted in favor of that block

this condition makes the block 'justified'

when another block is justified on top of a justified block, it is finalized
                
finilizing a block is comitting a block to the canonical chain

only epoch boundary slots can be justified, finalized

only checkpoints can be justified and finalized

**supermajority link**

2/3 of total staked eth votes that checkpoint B is the correct descendant of checkpoint A
                
> this causes A to finalize and B to justify.

**incentives (rewards)**

honest proposing and validating blocks is rewarded with ETH

participating in sync committees

value of each  reward in each epoch is calculated from base_reward

base_reward is proportional to the validator's effective balance and inversely proportional to the number of validators.

**components that determine total reward**  
- **source vote (uint64 14)**
timely vote for the correct source checkpoint (most recent justified block)
- **target vote (uint64 26)**
timely vote for the correct target checkpoint (first block of most recent epoch)
- **head vote (uint64 14)**
timely vote for correct head block
- **sync committee (uint64 2)**
validator has participated in the committee
- **proposer reward (uint64 8)**
the validator has proposed a block in the correct slot

>the weights sum to 64

**penalties**  
absent and fail to act when called upon (offline, downtime) has penalties usually small amounts
                
**dishonest behavior (slashing)**

when a validator proposes multiple blocks in a single slot (**equivocating**)

- proposing multiple blocks for the same slot
- attesting to multiple blocks same slot
- contradicting previous checkpoint votes
- submitting contradictory attestations

dishonest behavior is slashable

**correlation penalty**

the amount of slashed eth is relative to the amount of validators being slashed at the time
                
**mass slashing**
100% of ETH slashed 

**exit period**  
validator's eth gets slowly slashed

portion of validator staked ETH destroy and the val removed from the network
                    
correlation penalty imposed half-way the forced exit period

**day 1** 0.5ETH initial penalty

**day 18** correlation penalty  
- (larger depending on how many more validators are being slashed
- max penalty entire stake

**day 36** ejection of the network 
                    
**fork choice**

optimal and honest network performance means only one new block at the head of the chain where all validators attest to it

is possible for validators to have different views of the head of the chain due to network latency or equivocation.

**LMD-ghost**  
the algorithm to decide which block to favor in a conflict.
            
algorithm identifies the fork that has the greatest weight of attestations in its history

**casper-FFG** included the fork choice algorithm with the rule 

follow the chain containing the justified checkpoint that has the greatest height

**height**
greatest distance from genesis block
            
this original fork choice algorithm was deprecated in favor of LMD-GHOST

**LMD-GHOST**  
*latest message-driven greedy heaviest obsberved sub-tree*
            
algorithm that selects the fork with the greatest accumulated weight of attestations as the canonical one (greddy heaviest subtree)

if multiple messages are received from a validator, only the latest one is considered (latest message-driven)

before adding a block to the canonical chain, every validator uses this rule

**inactivity leak**

**plausible liveness**  
as long as 2/3 is honest, following the protocol voting honestly, the chain can finalize irrespective of 
- attacks
- latency issues
- slashings
            
1/3 of total staked eth must be compromised to prevent the chain to finalize blocks

inactivity leak is a defense mechanism against liveness failure

activates if chain hasn't finalized 4+ consecutive epochs

if validators aren't attesting to the majority chain, their stake is gradually drained until the majority regains the 2/3 of total stake
            
**weak subjectivity**

**subjectivity**
reliance upon social information to agree on current state.

when there's multiple valid forks, nodes rely on information served from other nodes to execute and verify by itself to agree on current state of the network.

**objectivity**
only one possible valid chain that all nodes have to agree upon.
            
**weak subjectivity**
a chain that progresses objectively after some initial seed of information is retrieved socially.
            
subjectivity is inherent to proof of stake

counting historical votes (heviest vote weight) chooses the canonical chain

long-range attacks can happen because of subjectivity

if 33% of validators withdraw their stake but continue to attest and produce blocks, a conflicting fork with canonical chain is generated.
            
new nodes might be tricked into following the conflicting fork.
        
**weak subjectivity checkpoints**  
state roots that all network nodes agree belong to the canonical chain

the fork-choice algorithm trusts that the blockchain state is defined true in that checkpoint 

independently and objectively verifies the state of the chain from that poing onwards

serve as reverse limits, blocks before a checkpoint can't be reversed.

long-range attacks aren't possible with checkpoints.

ensuring the checkpoint is separated from the validator withdrawal period ensures that a validator gets slashed in an attempt to fork the chain before they can withdraw their stake

**wscp vs finalized blocks**

a node simply rejects the finalized block conflicting with the checkpoint
            
ethereum proof of stake requires a recent state from a trusted source to sync from

**attestations**

a validator is expected to create, sign and boradcast an attestation during every epoch

every epoch (32 slots) 6.4 minutes

attestation is for a specific slot in the epoch
            
source and target checkpoint

most recent justified block (source)

first block current epoch (target)
            
checkpoints enable the network to reach consensus about the state of the blockchain

**components**

- **aggregation_bits**  
a bitlist of validators  
position maps to the validator index in their comitte  
(0/1) indicate if the validator signed the data   
- **data**
details relating to the attestation   
once data is built, the validator index can be flipped to 0 to 1 showing they participated.

  - ***slot***
slot number the attestation refers to
  - ***index***
identifier of the committee the validator belongs to in a certain slot
  - ***beacon_block***
root hash of the block the validator sees at the head of the chain (result of the fork-choice algorithm)
  - ***source***
part of the finality vote indicating what validators sees as most recent justified block
  - ***target***
indicates where validators see the first block in current epoch  


- **signature**

validator signs the attestation and broadcasts it to the network

BLS signature aggregates the signature of individual validators
            
**aggregated attestation**  

attestations from individual validators are aggregated  within subnets before being broadcasted more widely

aggregating signatures allow to combine all signatures that agree with one data

aggregation_bits provides the index of each validator in their committee

can be used to query individual signatures if necessary
                
in each epoch a validator in each subnet is selected to be the aggregator

aggregator collects attestation it hears about the gossit network 

**attestation lifecycle**
- generation
- propagation
- aggregation
- propagation
- inclusion
            
**attestation rewards**

the reward a validator recieve to attestate is dependent on
- base reward
- inclusion delay

attestations get included one block later after ocurring

inclusion delay is 1
if the delay doubles two slots, the reward halves.
                
attestation reward = 7/8 x base reward x (1/inclusion delay)

**missing vote**
validators have 1 epoch max to submit attestation, if attestation was missed in epoch 0 they can submit with inlusion delay in epoch 1
                
**missing aggregator**

16 aggregators per epoch in total

random validators subscribe to two subnets for 256 epochs serving as backups
                
**missing block proposer**
an aggregator might also become a block proposer.

**keys**

public-private key cryptography

public key is basis for an address

private key signs transactions and data to prove the actions carried by the transactions come from the right owner of the address

ethereum keys are generated using elliptic curve cryptography

a new validator key was created in POS

aggregates validator signatures to reduce the amount of communication required for the network to reach consensus

**BLS sginature scheme**
allows aggregation of signatures

reverse engineering of aggregated individual validator keys
                
**validator key**

valiator signing key has 
- **private**   
signs on chain operations (attestations and block proposals)
- **public**  
included in tx data when a user deposits ETH to the staking contract

known as deposit data, validator identifier

the keys must be held in a hot wallet (online)

multiple validator keys can be derived from a single common secret key 

**mnemonics**
sequence of words that act as initial seed for a private key

**master key**

output from hash function of input (combination of mnemonics with additional data).

root of a tree

branches from this root can be derived using a hierarchical path child nodes == parent node hash and their index in the tree

m/44'/60'/0'/0`

master_key/ purpose / coin_type / account / change / address_index







                