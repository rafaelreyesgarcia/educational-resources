INTRO TO THE STACK
  Level 1: Ethereum Virtual Machine
    runtime environment for smart contracts

    smart contract and state changes are executed by transactions

    EVM handles transaction processing

    EVM uses a set of opcode instructions to execute specific tasks
      140 unique opcodes
    
    opcodes allow the EVM to be turing-complete
      the EVM can compute just about anything given the resources
    
    the EVM powers all applications without downtime

  level 2: smart contracts

    executable programs that run on ethereum

    written in programming languages that compile to EVM bytecode (opcodes)

    smart contracts are 
      open source libraries
      open API services always running
      provide functions for users and applications to interact with without permission
      any application can integrate a deployed smart contract

    level 3: ethereu nodes
      an application or user that wants to interact with a smart contract and change the state of the blockchain, has to connect to a node

      a node allows you to read data and send transactions to the network (write data)

      nodes are computers running software (ethereum client)

      a client is an implementation of ethereum that verifies all transactions in each block

      connect an application to ethereum via JSON-RPC API 
        application then is able to read data from the blockchain and broadcast new transactions

      level 4: ethereum client apis
        many libraries allow to connect and communicate with the blockchain

        npm install a javascript API to the frontend

      level 5: end-user applications
        user-facing applications
        primarily web and mobile apps

SMART CONTRACTS

  with the right input, a certain output is guaranteed
  a vending machine is a good example

  logic is programmed into it

  permissionless
    anyone can write and deploy a smart contract
    deploying a transaction is a transaction that needs gas to execute

  programming languages for smart contracts
    solidity
    vyper
    most be compile before they can be deployed
  
  composability
    are public and can be seen as open APIs
    you can call other smart contracts in your own custom smart contract

    smart contracts can deploy other smart contracts
  
  limitations
    they can't send HTTP request, not being able to connect to the world outisde of ethereum

    oracles allow to communicate with the external world

    max contract size 24KB or it runs out of gas
      the diamond pattern circunvents this limitation
  
  multisig contracts
    requires multiple valid signatures to execute a transaction
  
    divide responsability for contract execution and key management among multiple parties

    requires N amount of M possible acceptable signatures

    4/7 multisig are common
  
  smart contract languages

    curly-bracket languages
      solidity
      vyper
    
    intermediate language for EVM 
      yul
      yul+
    
    under development
      fe
    
    solidity
      object-oriented high level 
      curly-bracket (influenced by C++)
      statically typed (type of variable is known at compile time)
      inheritance
      libraries
        reusable code that can be called from different contracts
      complex user-defined types
      
    vyper
      phytonic
      strong typing
      efficient bytecode
      deliberately less features than solidity 
        no modifiers
        no inheritance
        no inline assembly
        no function overloading
        no operator overloading
        no recursive calling
        no infinite-length loops
        no binary fixed points
      
    yul yul+
      yul
      intermediate language for ethereum
      supports EVM and Ewasm'

      yul+
      low-level 
      initially designed for an optimistic rollup contract
      experimental upgrade proposal to yul
    
    FE
      statically typed for EVM 
      inspired by python and rust
      alpha release in jan 2021
    
  anatomy of smart contracts
    a program that runs at an address on ethereum
    data and functions that can execute upon receiving a transaction

    contract
      collection of functions and data (the contract's state)

      once deployed a contract lives at an address on the ethereum blockchain

      high value applications
        deal with high-value financial assets (defi)
        valuable items such as non-fungible tokens(NFTs)

      immutable
        contracts deployed in the EVM are immutable by default

        upgradeability mechanisms
          proxy patterns
          can be implemented but is hard

    a. data

      data is state 

      any data has to be assigned to a location
        storage
        memory
      
      it is costly to modify storage 

      object-oriented types

      address type
        can hold an ethereum address (20 bytes or 160 bits)
        returns a hexadecimal notation w/leading 0x

        identifies an account on ethereum
        
        an address represents a smart contract or external (user) accounts

      other types
        boolean
        integer
        fixed point numbers
        fixed-size byte arrays
        dynamically-sized byte arrays
        rational and integer literals
        string literals
        hexadecimal literals
        enums
    
      a.1 storage
        persistent data represented by state variables
        permanently stored on the blockchain

        type needs to be declared so that contract keeps track of how much storage it needs when it compiles

      a.2 memory
        values stored only during an contract function execution (message call) (transaction giving a contract function input data to produced a guaranteed output)
        
        temporal values cheaper to use
      
      a.3 environment variables
        global variables aside from variables defined in the contract

        default in the runtime environment

        block.timeStamp
          uint256
          current block epoch timestamp
        msg.sender
          address
          sender of the message (current call)
    
    b. functions

      functions can get or set information in response to incoming transactions

      2 types of function calls

        internal (don't create an EVM call)

          can only be accessed internally (within the contract or derived contracts)

        external (do create an EVM call)
          part of the contract interface, they can be called from external code via transactions

          external f can't be called internally
            f() doesn't work
            this.f() does 

      2 type of functions

        public
          called internally (within the contract) or externally (via messages)

        private 
          only visible for the contract they are defined in, not in derived contracts

        both functions and state variables can be public or private
      
      solidity example

        function update_name(string value) public {
          dapp_name = value;
        }

        parameter value of type string is passed into the function update_name
        the function is declared public, anyone can access it
        view is not declared, the contract state can be modified
      
      view functions
        functions promise not to modify the state of the contract's data

        getter functions (read-only) this type of function can be used to retrieve a user balance, read information on the blockchain

        function balanceOf(address _owner) public view returns (uint256 _balance) {
          return ownerPizzaCount {_owner};
        }

        what modifies the state?
          writing to state variables
          emitting events
          creating other contracts
          using selfdestruct
          sending ether via calls
          calling any function not marked by view or pure
          using low-level calls
          using inline assembly that contains certain opcodes
      
      constructor function

        only executed when the contract is first deployed
        these functions often initialize state variables to their specified values

        constructor() public {
          owner = msg.sender;
        }

        the owner is set to the address of the contract creator

        all smart contracts rely on external transactions (message calls) to trigger functions

        msg is a global variable that includes relevant data on a given transaction
          address of the sender
          ETH value of the tx
        
      built-in functions
        address.send() in solidity
        send(address) in vyper
      
        allow contracts to send ETH to other accounts
      
      writing functions
        parameter variable and type (if it accepts parameters)

        declaration of internal/external

        declaration of pure/view/payable

        returns type (if it returns a value)
      
    c. events and logs

      events allow to communicate with a smart contract from a front-end or other application

      when a tx is mined, smart contract emmit events and write logs to the blockchain and then the front-end can process that result
  
  smart contract libraries

    libraries contain
      reusable behavior
      implementation of various standards
    
    libraries are modules, written by other developers to allow implementing their behavior to your own smart contract

    libraries
      HQ20
      DappSys
      OpenZeppelin
    
    behaviors
      patterns 
      functions

    SafeMath DsMath
      libraries that provide arithmetic functions with overflow checks (not provided by solidity)
    
    standards
      defined to facilitate composability and interoperability

      including an ERC standard as part of a contract is best practice

      ERC20
      ERC721
      some ERCs are extensions to other ERCs as improvements
        ERC2612 improves usability to ERC20
      
    adding a library
      
      several libraries are packed using npm
      npm install would install them

      most tools look into node_modules for smart contract libraries
    
    when to use a library

      saves time by providing ready to use building blocks

      open source libraries are heavily audited and secure

      using libraries carry the risk of including code you aren't familiar with, which can produce unexpected behavior if not handled properly
  
  smart contract testing

    most important measure to improve security in a contract

    detail analysis and evaluation of a contract to
      asses the quality of its source code 
      identify bugs and vulnerabilities
      reduces posibility of software errors that could lead to exploits
    
    automated testing
      automated tools that carry out a scripted test for a contract

      uses few resources, is efficient and promises high level of coverage (higher than manual)

      can be configured with test data, to compare predicted behaviors with actual results

      1. functional testing
        verifies functionality of the contract
        every function works as expected

        certain conditions (parameters/values/arguments) should be known in order to use functional testing, to predict an expected outcome and compare it with the actual result

        1.a unit testing
          test individual components 
          simple, quick, clear explanation of what went wrong

          beneficial when adding new functionality (logic) to the code

          running a unit tests requires creating assertions
          
          assertions
            informal statements specifiying requirements for the contract

          unit testing tests each assertion and sees if it holds true under execution

          "only admin can pause contract"
          "non-admins can't mint new tokens"
          "contracts reverts on errors"

        1.b integration testing

          level higher than unit testing

          individual components of a contract are tested together

          approach detects errors arising from iteractions between different components of a contract or across multiple contracts

          integration testing is useful to ensure inheritence and dependency injection work properly 
        
        1.c system testing

          final phase of functional testing
          a system evaluates the smart contract as one fully integrated product

          checks if the contract performs as specified in the technical requirements

          checks the end-to-end flow from user's POV

          system testing is performed by deploying the smart contract to a production-like environment (testnets or development networks)

          end-users can broadcast transactions and report any issues with the contract's business logic and functionality

          system testing is important as code is immutable once deployed in mainnet 

      2. static/dynamic analysis

        automated testing methods that evaluate the security qualities of smart contracts

        techniques use different approaches

        2.a static analysis

          examines source code or bytecode before execution
          can be debugged without running the program
          can detect common vulnerabilities

        2.b dynamic analysis

          require executing the contract in a runtime environment 

          relies on runtime as issues mught be idenfitied only during production, a live environment

          details identified vulnerabilities and property violations

          assuming the inputs are right, all the above applies

          but when the user inputs wrong values to the smart contract, this can cause
            resource leaks
            crashes
            unintended code execution
          
          fuzzing is a dynamic analysis technique

          during fuzz testing, a fuzzer feeds invalid and malformed data to monitor how the contract responds to those inputs

    manual testing

      human aided
      programmer has to execute testing steps manually

      auditors/developers inspect line by line 

      complimenting automated and manual testing is best practice
    
      1. code audits
        detail evaluation of a smart contract source code

        uncovers
          failure-points
          security flaws
          poor development practices
        
        audits require an attacker mindset (blackhat) to mapp out possible attack vectors

      2. bug bounties
        financial reward to an individual who discovers a bug and reports it to developers (whitehat)

      testing vs formal verification

        testing can verify certain conditions (inputs) will behave/be processed as expected (produced an expected output)

        testing can't verify that conditions that weren't tested will behave/be processed as expected

        functional correctness
          when a program behaves as required for all sets of input values and conditions

        formal verification is incorporated for assessing the correctness of smart contracts

        formal verification uses mathematically rigorous techniques 

      testing tools

        unit testing

          solidity-coverage

          waffle

          remix tests

          openzeppelin test helpers

          truffle smart contract test framework

          brownie unit testing framework

          foundry tests

          etheno
        
        static analysis tools
          mythril
          slither
          rattle
        dynamic analysis tools
          echidna
          harvey
          manticore
        
        contract auditing services
          consensys dilligence
          certiK
          trail of bits
          peckshield
          quantstamp
          openzeppelin
        
        bug bounty platforms
          immunefi
          hackerone

  compiling smart contracts

    the EVM needs to run bytecode

    the smart contract written in a high-level language such as solidity needs to be compiled to a machine-level language that the EVM can process (such as bytecode)

    web apps

      the compiler produces the application binary interface (ABI)

      ABI is needed so the application can understand the contract and call it's functions

      ABI is a JSON file that describes the deployed contract and its smart contract functions

      ABI bridges the gap between web2 and web3

      a javascript client library will read the ABI in order to call the functions in a smart contract through the web app's interface
  
  deploying smart contracts

    contract's bytecode, generated through compilation
    ETH for gas to broadcast the contract deployment transaction
    a deployment script or pluuugin
    access to an ethereum node
      your own
      public node
      via API key using a node service 
        infura
        alchemy
    
    tools to deploy a contract
      hardhat
      truffle
    
    once a contract is deployed, it will have an ethereum address like other accounts

    the steps to deploy will depend on the tooling you use

    each tooling write a script to handle the deployment steps different 
  
  verifying smart contracts

    contracts should be trustless (a user doesn't have to trust the company and developers before interacting with a contract)

    source code verification assures users and developers that the published contract code is the same code running at the contract address on the blockchain

    source code verification

      checks that the published code is the same code at the contract address 

      developers compile contract's source code to bytecode 

      bytecode is necessary for executing contract logic in the EVM

      smart contract verification enables investigating what the conctract does high-level without reading bytecode

    full verification

      checks the source code for different parts of the code that doesn't affect compiled bytecode
        comments 
        variable names
      
      two source codes with different comments and variable names would verify the same contract

      appending extra data to the bytecode serves as a cryptographical guarantee to avoid wrong verifications

        extra data is a fingerprint of the compilation
        extra data is found in the metadata, and the hash of this file is appended to the bytecode of the contract

      contract metadata
        information about the compilation of the contract
        source files and hashes

        if even one byte of the compilation settings or source files changes, the hash produced from the metadata will be different, invalidating the cryptographic proof that serves as a shield 
      
      full verification appends the hash of the contract metadata to the bytecode to verify the compilation settings, so this hash can be compared with the hash of any contract to see if it matches and verifies that it is indeed the same contract

    trustlessness

      smart contracts are immutable and can't be altered
      
      a contract will only execute the business logic defined in the code at the time of deployment 

      no one can tamper with the behavior of a deployed contract

      trustlessness is achieved when the contract code is available for independent verification

      bytecode is public but difficult to read

      developers publish the source code of contracts (high-level) for better readability and auditing 

      but then published code is difficult to verify that it matches the bytecode of the actual contract stored in the ethereum address

    source code verification tools provide guarantees that a smart contract's source code files matches the assembly code

    user safety

      malicious developers can deceive users by inserting malicious code in a smart contract

      without verification, smart contracts can have
        backdoors
        controversial access control mechanisms
        exploitable vulnerabilities

    how to verify source code

      deploying requires sending a tx with data payload(compile bytecode) to a special address

      data payload is generated by compiling source code plus the constructor arguments of the contract instance appended to the data payload in the tx

      compilation is deterministic
        always produces the same output
      
      steps
        1. input source files and compilation settings to a compiler
        2. compiler outputs the bytecode of the contract
        3. get the bytecode of the deployed contract at a given address
        4. compare the deployed bytecode with the recompiled bytecode
          if code matches, contract gets verified
        5. if the metadata hashes at the end of the bytecode match
          contract gets fully verified
      
        immutable variables won't work for this process
    
    source code verification tools

      etherscan
        recompiles contract bytecode from original data payload (source code, library address, compiler settings, contract address, etc)

        if recompiled bytecode is associeated with the on-chain contract bytecode, the contract gets verified

        it doesn't compare metadata hash

        matches in etherscan are partial matches
      
      sourcify
        verifies contracts on different EVM based networks
        uses ABI and NatSpec

        supports full matches with the metadata hash
        
        verified contracts are served in the public repository on HTTP and IPFS
        
          allows fetching metadata of a file of a contract over IPFS
        
      tenderly
        can verify a contract privately
  
  upgrading smart contracts

    smart contracts are self-executing programs that run in the EVM

    immutable by design, which prevents any updates to the business logic once deployed

    overtime, several upgrade patterns have emerged to address not being able to mutate a contract after deployment (update it or fix vulnerabilities)

    a smart contract upgrade involves in changing the business logic while preserving the contract state

    upgradability is not the same as mutability

    you can't change a program, you can change the code that executes when users interact with the program

    methods

      1. contract migration
        creating multiple versions of smart contract and migrating state from old to a new instance

        based on versioning

        creating and managing unique states of the same software

        involves deploying a new instance of an existing smart contract and transferring storage and balances to the new contract 

        newly deployed contract will have empty storage 

        allows to recover data from old contract and write it to the new implementation



      2. data separation
        create separate contracts to store busiess logic and state

        users interact with logic contract, data is stored in storage contract

        logic contract
          contains code executed when user broadcasts a tx
        
          holds the storage contract and interacts with it to get and set data
        
        storage contract
          holds the state associated with the contract 
            user balances and addresses
        
          owned by the logic contract, configured with the logic contract's address 

          storage contract is immutable
            but the logic contract it points to can be replaced with a new implementation
          
        this method requires updating the logic's contract address in the storage contract 

        easier to implement than contract migragtion

        complex authorization schemes need to be implemented to protect smart contracts from malicious upgrades

        logic contract calls the storage contract

      3. proxy patterns
        using proxy patterns to delegate function calls from an immutable proxy contract to a modifiable logic contract

        the storage contract (called proxy) calls the logic contract during code execution

        reverse of the data separation method

        user interacts with proxy contract, that stores data but doesn't hold business logic

        proxy contract stores address of the logic contract and delegates all fucntion calls to the logic contract, using delegatecall function

        after the call is forwarded to the logic contract, return data is retrieved and returned to the user

        delegatecall is an opcode that allows a contract to call another contract, while execution happens in the context of the contracting making the call

        delegatecall means the code at the target address is executed in the context of the calling contract
          don't change
            msg.sender
            msg.value 

        requires writing a custom fallback functions that specifies how the proxy should handle function calls it doesn't support

        proxy contract is immutable but logic contracts with updated business logic can be created 

      4. strategy pattern
        creating an immutable main contract that interfaces and relies on flexible satellite contracts to execute specific functions

        build a smart contract that calls functions from other contracts

        main contract 
          contains business logic, but interfaces with other contracts (satellite) to execute certain functions

          stores address for each satellite contract, can switch between different implementations of the satellite contract

        pattern mostly useful for minor upgrades (as the core is immutable)

      5. diamond pattern 
        (delegates function calls from a proxy contract to logic contracts)

        improvement on the proxy pattern

        diamond can delegate function calls to more than one logic contract

        facets
          logic contracts in a diamond pattern
        
        creates a mapping in the proxu contract that maps function selectors to different facet addresses

        allows to upgrade a small part of the contract 

        all contracts have 24KB size limit, diamond pattern solves this problem by splitting functions across multiple logic contracts

        proxy patterns adopt a catch-all approach to access controls
          an entity with access to upgrade functions can change the entire contract
        
        diamond pattern enables a modular permission approach
    
    pros and cons of upgrading contracts

      pros
        fixes vulnerabilities post-deployment

        devs can use logic upgrades to add new features without breaking old behavior

        smart contract upgrades can improve safety since bugs can be fixed

        room to develop the dapp overtime
      
      cons

        upgrades != immutability
          has implications for decentralization and security
        
        users must trust developers to not modify contracts maliciously 
          defeats the purpose of trustlesness
        
        adding a layer of functionality can introduce risky complexities

        insecure access control or centralization can make it easier for devs to perform malicious upgrades
    
    best practices when upgrading contracts

      use secure access control/authorization mechanisms to prevent unauthorized smart contract upgrades

      upgrading a contract require high level of dilligence to prevent introduce vulnerabilities

      theres a cost involved in upgrading the state of a contract
    
  smart contract security

    contracts usually cannot be changed to patch security flaws

    tooling needed to write secure smart contract code
      writing (IDE)
      compiling (compiler)
      testing (truffle)
      deploying (hardhat)
    
    development process
      code stored in version control system (git)

      code modifications via pull requests

      all pull requests have one reviewer

      single command compiles, deploys and runs a suite of tests against code using development ethereum
      environments (truffle/hardhat)

      run the code through code analysis tools (mythril/ slither) before each pull request is merged

      solidity doesn't emit any compiler warnings

      code needs to be well documented
    
      defisafety provides a checklist for process quality
    
    attacks and vulerabilites
    
      re-entrancy
        while EVM can't run multiple contracts at the same time, a contract can call a different contract, pausing the calling contract's execution and memory state until the call returns

        this pausing and re-starting can produce re-entrancy

      front-running

      ETH send rejection

      integer overflow/underflow

      security tools

        slither
        mythx
        mythril
        manticore
        securify
        ERC20 verifier
        formal verification
      
  formal verification

    smart contracts can handle a large amount of value

    security is critical

    formal verification uses formal methods

    has been used for years to ensure correctness of critical hardware and software systems

    can prove that a contract's business logic meets a predefined specification

    process of evaluating correctness of a system

    allows to check if the behavior of a system satisfies some requirements 

    expected behaviors of a system are described using formal modeling

    specification languages enable creating formal properties

    formal verification can verify that the implementation of a contract complies with its specification and derived mathematical proof of the contract's correctness

    formal model
      mathematical description of a computational process

      programs are abstracted into mathematical functions with the model describing how outputs to functions are computed given an input
    
    formal specification

      types of formal specifications

      high-level
        model oriented specification

        finite state machine
        temporal logics
          safety
            freedom from deadlock
          liveness
      
      low-level
        property oriented specifications
      
      hoare-style properties
        hoare logic
      
      trace-level properties
        control flow graph CFG
      
    formal verification techniques

      model checking
    
      theorem proving

      symbolic execution
    
    benefits of formal verification
      reliability
      prove functional correctness
      ideal verification targets
      faster development cycle
    
    drawbacks
      cost of manual labor
      false negatives
      performance issues
    
    formal verification tools
      act
      scribble
      dafny
      solidity SMTCHecker
      solc-verify
      KEVM
    
    logical frameworks for theorem proving
      isabelle
      coq
      manticore
      hevm

  composability

    combining distinct components to create new systems or outputs

    developers can reuse existing software components to build new applications

    smart contracts act like APIs so anyone can interact with the contract or integrate them into their dapps to enhance functionality

    composibility principles

      modularity
        ability of individual components to perform a specific task
      autonomy
        composable components must be able to operate independently
      discoverability
        developers can't call external contracts or integrate libraries if they are not publicly available
      
      benefits of composability

        shorter development cycle
          open source means every problem has to be solved once (no wheel reinventing)
        greater innovation
          composability encourages developers to reuse, modify, duplicate or integrate open-source code
        better UX
          users can access greater functionality when dapps integrate external smart contracts instead of an ecosystem where applications can't communicate
        
      examples of composability

        token swaps
        governance
        identity management

DEVELOPMENT NETWORKS

  a development network can be used to create a local blockchain instance to test a dapp

  much faster iteration than a public testnet (no need for tesnet faucet)

  ethereum clients designed specifically for local development

  ganache
    fire up a personal ethereum blockchain to run tests, execute commands and inspect state 

    both GUI and command-line tool available, part of the truffle suite of tools
  
  hardhat network
    local ethereum network designed for development
  
  local beacon chains
    some consensus clients have built-in tools for spinning up local beacon chains for testing purposes

  publick ethereum test-chains
    goerli
    sepolia
    ropsten (deprecated in Q4 22)
    rinkeby (deprecated in Q2 23)

DEVELOPMENT FRAMEWORKS

  truffle
    development environment, testing framework, build pipeline
  
  hardhat
    ethereum development environment
  
  ape
    smart contract development tool for phytonists

  brownie
    python based development environment and testing framework
  
  embark  
    integrates with IPFS and whisper
  
  web3j
    developing blockchain applications on the JVM
  
  openZeppelin SDK
    smart contract toolkit
      develop
      compile
      upgrade
      deploy
      interact
  
  create eth app

  scaffold eth
    ethers.js hardhat react components and hooks
  
  the graph
    querying blockchain data efficiently
  
  alchemy
    development platform
  
  foundry
    portable modular toolkit written in rust

ETHEREUM CLIENT APIs

  JAVASCRIPT API LIBRARIES

    every ethereum client implements the JSON-RPC specification for a uniform set of endpoints that applications can rely on

    connecting to ethereum nodes

      using providers, libraries allow to connect to ethereum and read its data over JSON-RPC, INFURA, etherescan, alchemy or metamask

      ethers
        const provider = new ethers.providers.Web3Provider(window.ethereum)

        const signer = provider.getSigner()
      
      web3js
        var web3 = new Web3("http://localhost:8545")
        or
        var web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"))

      connecting to an ethereum node allows us to query
        block numbers
        gas estimates
        smart contracgt events
        network id
    
    libraries give functionality to
      create wallets
      manage keys
      sign transactions

      ethers
        mnemonic = "announce room limb pattern dry unit scale effort smooth jazz weasel alcohol"
        walletMnemonic = Wallet.fromMnemonic(mnemonic)
    
    javascript client libraries allow an application to call smart contract functions by reading ABI of a compiled contract

    the ABI explains the contract's functions in a JSON format and allows to use the function like a normal javascript object

    utility functions
      handy shortcuts 

      eth values are in wei by default

      1 ETH = 1,000,000,000,000,000,000 WEI

      web3.utils.toWei converts ether to wei for you

      ethers
        balance = await provider.getBalance("ethers.eth")

        ethers.utils.formatEther(balance)
    
    available libraries

      web3.js
      ethers.js
      the graph
      light.js
      web3-wrapper (typescript)
      alchemyweb3
      alchemy NFT API 
  
  BACKEND API LIBRARIES

    libraries abstract the complexity of interacting directly with a node

    alchemy
    blockcypher
    infura
    cloudflare ethereum gateway
    datahub
    nodesmith
    ethercluster
    quicknode
    chainstack
    web3j
    rivet
    nethereum
    tatum
    watchdata
    zmok
  
  JSON-RPC API
    for an application to interact with ethereum (read/write data) it must connect to a node

    every client implements JSON-RPC specification for a uniform set of endpoints that applications can rely on

    JSON-RPC 
      stateless light-weight remove procedure call protocol

      defines several data structures and the rules to process them

      transport agnostic (same concept over)
        sockets
        HTTP
      
      JSON RFC 4627 as data format
    
    ethereum clients may use different programming languages when implementing the JSON-RPC specification

    javascript and backend API libraries provide wrappers on top of the JSON-RPC API

    libraries allow to write intuitive easier methods to initialize JSON-RPC requests

    consensus client APIs
      allows users to 
        query information about the node
        request directly from a node
          beacon blocks
          beacon state
          consensus-related information
      
      engine API
        an internal API is also used for inter-client communication (between consensus and execution client) 
    
    execution client SPEC

      hex value encoding
        there's two data types that get passed over JSON 
          unformatted byte arrays
          quantities
        
        both are passed with a hex encoding 
      
      quantities
        integers, numbers
        encoding quantities as hex, requires the prefix 0x

        examples
          0x41 (65 in decimal)
          0x400 (1024 in decimal)
      
      unformatted data
        byte arrays, account addresses, hashes, bytecode arrays

        encode as hex prefix 0x two hex digits per byte

        examples
          ox41 (size 1, "A")
          0x004200 (size 3, "\0B\0")
          0x (size 0, "")
      
      default block parameter

        methods that have default block parameter
          eth_getBalance
          eth_getCode
          eth_getTransactionCount
          eth_getStorageAt
          eth_call
        
        hex String - integer block number
        string "earliest" - genesis block
        string "latest" - latest mined block
        string "pending" - pending state/txs
      
    CURL examples

      use individual JSON_RPC API endpoints using command-line tool curl

    JSON-PRC methods require data from ethereum network

    3 categories of JSON-RPC methods

      gossip 
        track the head of the chain
        how txs make their way around the network
        find their way into blocks
        how clients find out about new blocks

        eth_blockNumber
        eth_sendRawTransaction

      state
        report current state of all data stored
        state is like one big shared piece of RAM, including account balances, contract data and gas estimations

        eth_getBalance
        eth_getStorageAt
        eth_getTransactionCount
        eth_getCode
        eth_call
        eth_estimateGas

      history
        fetches historical records of every block back to genesis

        like one large append-only file and includes
          block headers
          block bodies
          uncle blocks
          transaction receipts
        
    JSON-RPC API Methods

      1. web3_clientVersion
        returns string - current client version
        param
          none
        
        example
          request

          curl -X POST --data '{"jsonrpc":"2.0":"web3_clientVersion", "params":[],"id":67}'

          result
          
          {
            "id": 67,
            "jsonrpc":"2.0",
            "result": "Mist/v0.9.3/darwin/go1.4.1"
          }
      
      2. web3_sha3
        returns Keccak-256 of the given data
        param
          DATA 
            data to convert into SHA3 hash
          
        example 
          curl -X POST --data '{"jsonrpc":"2.0", "method":"web3_sha3", "params":["0x68656c6c6f20776f726c64"], "id":64}'

        result
          {
            "id":64,
            "jsonrpc":"2.0",
            "result":"0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad"
          }
        
      3. net_version
        returns string - the current network id
        param
          none
        
        chainlist.org

        common network ids
        ethereum mainnet 1
        morden testnet 2
        ropsten testnet 3
        rinkeby testnet 4
        goerli testnet 5

        example
          curl -X POST --data '{"jsonrpc":"2.0","method":"net_version", "params":[],"id":67}'

        result
          {
            "id": 67,
            "jsonrpc":"2.0",
            "result":"3"
          }
      
      4. net_listening
        returns true if client is actively listening for network connections

        param
          none
        
        returns boolean when listening

        example
          curl -X POST --data '{"jsonrpc":"2.0","method":"net_listening","params":[],"id":67}'
        
        result
          {
            "id":67,
            "jsonrpc":"2.0",
            "result":true
          }
      
      5. net_peerCount

        returns quantity - integer of the number of connected peers

        param
          none
        
        example
          curl -X POST --data '{"jsonrpc":"2.0","method":"net_peerCount","params":[],"id":74}'
        
        result
          {
            "id":74,
            "jsonrpc":"2.0",
            "result":0x2
          }
      
      6. eth_protocolVersion
        returns string - current ethereum protocol version

        param
          none

        example
          curl -X POST --data '{"jsonrpc":"2.0","method":"eth_protocolVersion","params":[],"id":67}'

        result
          {
            "id":67,
            "jsonrpc":"2.0",
            "result":"54"
          } 
      
      7. eth_syncing
        returns object|boolean
        
        object with sync status data
          properties

          startingBlock - quantity
            block at which the import started(only reset after the sync reached his head)
          currentBlock - quantity
            current block same as eth_blockNumber
          highestBlock - quantity
            estimated highest block
        
        if the node is not synced, returns false 

        params 
          none

        example 
          curl -X POST --data '{"jsonrpc":"2.0","method":"eth_syncing","params":[],"id":1}'

        result
          {
            "id":1,
            "jsonrpc":"2.0",
            "result": {
              startingBlock: '0x384',
              currentBlock: '0x386',
              highestBlock: '0x454'
            }
          }

      8. many more JSON-RPC API methods
    
    deploying a contract using JSON_RPC

      complexity is abstracted away using libraries like web3.js and web3.py
        easier to understand
        less error prone
      
      1. run an geth node

      2. enable HTTP JSON-RPC 
        most clients default to serving on localhost:8545

        --http flag is supplied on geth starting up

        use the geth node on a private development chain to not need real ether

        geth --http --dev --mine --miner.threads 1 --unlock 0 console2>>geth.log
          starts HTTP RPC interface on localhost:8545
        
        numbers (quantities) are hex coded, so to return balance in ethere as a number, web3 can be used from the geth console
          web3.fromWei("0x1639e49bba16280000", "ether")
      
      3. compile contract to byte code
        
        contract Multiply7 {
          event Print(uint);
          function multiply(uint input) returns (uint) {
            Print(input * 7);
            return input * 7;
          }
        }

        install solc solidity compiler

        bytecode generated from compiling the contract

        0x6060604052341561000f57600080fd5b60eb8061001d6000396000f300606060405260043610603f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063c6888fa1146044575b600080fd5b3415604e57600080fd5b606260048080359060200190919050506078565b6040518082815260200191505060405180910390f35b60007f24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da600783026040518082815260200191505060405180910390a16007820290509190505600a165627a7a7230582040383f19d9f65246752244189b02f56e8d0980ed44e7a56c0b200458caad20bb0029
      
      4. estimate gas fees to deploy

        RPCC interface has eth_estimateGas method that will give an estimate
        the data in params is the bytecode
        from is the address deploying

          curl --data '{"jsonrpc":"2.0","method":"eth_estimateGas","params":["from":"0x9b1d35635cc34752ca54713bb99d38614f63c955","data":"0x6060604052341561000f57600080fd5b60eb8061001d6000396000f300606060405260043610603f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063c6888fa1146044575b600080fd5b3415604e57600080fd5b606260048080359060200190919050506078565b6040518082815260200191505060405180910390f35b60007f24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da600783026040518082815260200191505060405180910390a16007820290509190505600a165627a7a7230582040383f19d9f65246752244189b02f56e8d0980ed44e7a56c0b200458caad20bb0029"], "id":5 }' -H "Content-Type: application/json" localhost:8545

      5. deploy the contract
        curl --data '{"jsonrpc":"2.0","method":"eth_sendTransaction","params":["from":"0x9b1d35635cc34752ca54713bb99d38614f63c955", "gas":"ox1c31e", "data":"0x6060604052341561000f57600080fd5b60eb8061001d6000396000f300606060405260043610603f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063c6888fa1146044575b600080fd5b3415604e57600080fd5b606260048080359060200190919050506078565b6040518082815260200191505060405180910390f35b60007f24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da600783026040518082815260200191505060405180910390a16007820290509190505600a165627a7a7230582040383f19d9f65246752244189b02f56e8d0980ed44e7a56c0b200458caad20bb0029"], "id": 6}' -H "Content-Type": application/json" localhost:8545
      
      6. transaction is accepted by node, tx hash is returned

        the hash is used to track the tx

        {
          "id":6,
          "jsonrpc":"2.0"
          "result":"0xe1f3095770633ab2b18081658bad475439f6a08c902d0915903bafff06e6febf"
        }
      
      7. determine the address where the contract is deployed

        each executed transaction will create a receipt containing info about the tx

        if a tx creates a contract, it will contain the contract address

        retrieve the receipt with eth_getTransactionReceipt RPC method

        curl --data '{"jsonrpc":"2.0","method":"eth_getTransactionReceipt","params":["0xe1f3095770633ab2b18081658bad475439f6a08c902d0915903bafff06e6febf"], id:7}' -H "Content-Type: application/json" localhost:8545

        result
        {
          "jsonrpc":"2.0",
          "id":7,
          "result":       
          {
            "blockHash":"0x77b1a4f6872b9066312de3744f60020cbd8102af68b1f6512a05b7619d527a4f",
            "blockNumber":"0x1",
            "contractAddress":"0x4d03d617d700cf81935d7f797f4e2ae719648262",
            "cumulativeGasUsed":"0x1c31e",
            "from":"0x9b1d35635cc34752ca54713bb99d38614f63c955",
            "gasUsed":"0x1c31e",
            "logs":[],
            "logsBloom":"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "status":"0x1",
            "to":null,
            "transactionHash":"0xe1f3095770633ab2b18081658bad475439f6a08c902d0915903bafff06e6febf",
            "transactionIndex":"0x0"}}
        
        contract address - 0x4d03d617d700cf81935d7f797f4e2ae719648262
    
    interacting with smart contracts

      eth_sendTransaction requires several arguments
      from
        public address of our account
      to
        contract address
      data
        contains a payload that defines which method must be called and with which arguments
        ABI is a JSON file that defines how to define and encode data for the EVM
      

      bytes of the payload define which method in the contract is called

      first 4 bytes from the keccak hash over the function name and argument types, hex encoded

      web3.sha3("multiply(uint256)").substring(0, 10)
        returns 0xc6888fa1
      
      ABI encodes the arguments, in this case a uint256

      argument of a uint256 of 6 encodes to
        0000000000000000000000000000000000000000000000000000000000000006
      
      combining function selector and encoded argument
        0xc6888fa10000000000000000000000000000000000000000000000000000000000000006
      
      this is sent to the node

      curl --data '{"jsonrpc":"2.0","method":"eth_sendTransaction", "params":[{"from": "0xeb85a5557e5bdc18ee1934a89d8bb402398ee26a", "to":"0x6ff93b4b46b41c0c3c9baee01c255d3b4675963d", "data":"0xc6888fa10000000000000000000000000000000000000000000000000000000000000006"}], "id":8}' -H "Content-Type: application/json" localhost:8545

      a transaction hash is returned and after retrieving the receipt with eth_getTransactionReceipt

      the receipt returns

      {
        blockHash: "0xbf0a347307b8c63dd8c1d3d7cbdc0b463e6e7c9bf0a35be40393588242f01d55",
        blockNumber: 268,
        contractAddress: null,
        cumulativeGasUsed: 22631,
        gasUsed: 22631,
        logs: [{
          address: "0x6ff93b4b46b41c0c3c9baee01c255d3b4675963d",
          blockHash: "0xbf0a347307b8c63dd8c1d3d7cbdc0b463e6e7c9bf0a35be40393588242f01d55",
          blockNumber: 268,
          data: "0x000000000000000000000000000000000000000000000000000000000000002a",
          logIndex: 0,
          topics: ["0x24abdb5865df5079dcc5ac590ff6f01d5c16edbc5fab4e195d9febd1114503da"],
          transactionHash: "0x759cf065cbc22e9d779748dc53763854e5376eea07409e590c990eafc0869d74",
          transactionIndex: 0
        }],
        transactionHash: "0x759cf065cbc22e9d779748dc53763854e5376eea07409e590c990eafc0869d74",
        transactionIndex: 0
      }     

      the receipt contain a log
      log is generated by EVM on transaction execution
      
DATA AND ANALYTICS

  block explorers

    portal to ethereum's data

    offer RESTful API gateways that provide readability into real-time data on 
      blocks
      txs
      miners
      accounts
      on-chain activity in general
    
    data
      block explorers provide an interface for getting (reading) on-chain data

      data can be execution or consensus data

      execution data
        txs that have been executed in a specific block

      consensus data
        blocks themselves and the validators who proposed them
      
      standard data
        block height
        timestamp
        txs
        fee recipient
        block reward
      
      advanced data
        hash
        parent hash
        stateRoot
      
      gas
        estimated units for different scenarios
        contracts that are consuming gass
        accounts that are spending gas
      
      tx

        standard data

          tx hash
          status
          block
          from
          to
          timestamp
        
        advanced data
          gas limit
          gas used
          gas price
          nonce
          input data
      
      accounts
        account address
        ETH balance
        total ETH value
        tokens
        tx history
      
      smart contract data

        contract creator
        creation tx
        source code
        contract ABI
        contract creation code
        contract events
      
      tokens
        type
        price
        market cap
        total supply
        holders
        transfers
        tx history
      
      network
        total txs
        tps
        eth price
        total ETH supply
        market cap
      
      consensus data

        epoch number
        finalized status
        time
        attestations
        deposits
        slashings
        validators

        slot
          epoch
          slot number
          status
          time
          proposer
          block root
          parent root

        blocks
          proposer
          epoch
          slot
          attestations
        
        validators
        attestations
        network
      
  the graph

    decentralized indexing protocol for organizing blockchain data

    serverless applications that run entirely on public infrastructure

    using GraphQL developers can query any open APIs known as sub-graphs to acquire necessary information

    dune analytics
      pre-process blockchain data into relational database (PostgreSQL and Databricks SQL)

      allows users to query blockchain data using SQL and build dashboards


STORAGE

  the main ethereum blockchain was designed to store all data related to smart contracts, accounts and nodes

  storing large amount of data such as files (video, audio, images) wouldn't allow nodes to download the whole chain as the size would be too big

  decentralized storage solutions have these features

    persistence mechanism / incentive structure

      allow to persist data forever

      blockchain-based persistence is achieved by running nodes of a network 

      contract-based persistance relies on the intuition that data can't be replicated by every node and stored forever, so instead it is upkept with contract agreements

      IPFS
        distributed system to store and access files, websites, applications and data

    data retention enforcement 

      challenge mechanism

        making sure data is retained is achieved by using a cryptographic challenge that is issued to the nodes to make sure they still have the data

        Arweave's proof of access

        issue a challenge to the nodes to see if they have the data at both the most recent block and a random block in the past, if the node can't come up with the answer they are penalized

        0Chain
        skynet
        arweave
        filecoin
        crust network

    consensus
      these tools to retain data in a persistent manner have their own versions of consensus mechanisms but can be POW and POS

      POW
        skynet
        arweave
      POS
        ethereum
        filecoin
        0Chain
        crust network

IDEs

  web-nbased IDEs
    remix
    chainIDE
    replit
    tenderly sandbox
    ethfiddle
  
  desktop ides
    visual studio code
    atom
    jetBrains
    remix desktop
  
  plugins and extensions
    solidity
    prettier solidity

PROGRAMMING LANGAUGES
  other programming languages are used to build
    implementations
    APIs
    development frameworks
    testing tools

  dart
  delphi
  golang
  .NET
  java
  javascript
  python
  ruby
  rust