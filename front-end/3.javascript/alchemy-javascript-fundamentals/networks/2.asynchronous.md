# asynchronous programming

## callback functions

functions are **first-class** objects because functions can be
- stored
- returned
- passed as arguments

a function is useful as an argument of another function when the function caller doesn't have direct access to functionality

callbacks are commonly associated with asynchronous programming since they allow to pick up code execution at a later time

common asynchronous tasks 
- waiting for user feedback
- waiting on a server response
- waiting for an animation to complete

### 1. run callback 

because functions are first-class citizens in javascript, that means we can use them as callbacks

```js
function simpleFunction(fn) {
    // invoke the callback function
    fn();
}

simpleFunction(function callbackFunction() {
    console.log('hi');
});
```

`callbackFunction` is passed as an argument to `simpleFunction` and immediately called 

### 3. asynchronous callback

callbacks are run at a specific time when they are passed to another function.

asynchronous callbacks are helpful for 
- AJAX requests to the server
- waiting for a user response
- animations

the web API `setTimeout` will run code after a set amount of time

```js
setTimeout(function callback() {
    // the code to run after 1000 milliseconds
}, 1000);

// code down here runs synchronously (before the callback)
```

the first argument to `setTimeout` is the callback function and the second argument is the number of milliseconds to wait 


invoke callbackFunction in `setTimeout` after 1000 milliseconds

```js
function runCallbackAsync(callbackFunction) {
  setTimeout(() => {
    callbackFunction();
  }, 1000);
  return 'timer set';
}

function asyncHello() {
  console.log('async hello!');
  console.log('done');
}

console.log(runCallbackAsync(asyncHello));
```

### dialog callback

create a callback to be invoked by user interaction.

a basic dialog component for a web application can use a class to create a new instance of the dialog

`onClose` will take a callback function as an argument and store it on the dialog instance

`close` function will be used to close the dialog, and by closing, the callback will be invoked

in practice, wiring up logic to execute when a dialog is closed or open is useful, like refreshing data on the page

```js
const dialog = new Dialog();

dialog.onClose(function() {
    // refresh data on the page to reflect state 
    // changes made inside of the dialog
    refreshData(); 
});

class Dialog {
  onClose(callbackFunction) {
    // store the callback
    this.callbackFunction = callbackFunction;
  }

  close() {
    // invoke the callback
    this.callbackFunction();
  }
}
```

### 4. dialog callbacks

wire up multiple callback functions

each time `onClose` is called, we need to store an additional callback function on the class. once `close` is called we can invoke all callback functions

requires to initialize an array on the `Dialog` class the `constructor` is a good palce to initialize state, called once when a new instance is created.

```js
class DialogMultipleCallbacks {
  constructor() {
    this.callbacks = [];
  }
  onClose(callbackFunction) {
    // store the callbacks
    this.callbacks.push(callbackFunction);
  }
  close() {
    this.callbacks.forEach(elem => {
      elem();
    });
  }
}
```

### for each callback

function takes two parameters
- an array of elements
- a callback function that we want to run for each element

invoke the callback with both the current element in te array and the index

```js
forEach(['a','b','c'], (e,i) => {
    console.log(e,i);
});

// a, 0
// b, 1
// c, 2

function forEach(arr, callback) {
  // for each element in the arr, run the callback, passing in the element
  for (let i = 0; i < arr.length; i++) {
    callback(arr[i], i);
  }
}
```

### map callback

write our own custom map function

take an array and run some function over each element, replacing that element with the function's return value

```js
const newArray = map([1,2,3], (x) => {
    return x * 2;
});

console.log(newArray); // [2,4,6]
```
