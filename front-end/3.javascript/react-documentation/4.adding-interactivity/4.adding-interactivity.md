# **ADDING INTERACTIVITY**

## responding to events

data on the screen can update in response to user input.

data that changes over time is called *state*

you can add state to any component.

adding event handlers to JSX is possible.

event handlers are custom functions to trigger in response to user interactions like
- clicking
- hovering
- focusing on form inputs
- etc

**adding event handlers**

to add an event handler, first define the function and then pass it as prop to a JSX tag.

```jsx
export default function Button() {
  return (
    <button>
      I don't do anything
    </button>
  );
}
```

follow 3 steps to add interactivity to a button
- declare a function `handleClick` inside `Button`
- implement logic inside function (use `alert` to show a message)
- add `onClick={handleClick}` to `<button>` JSX

```jsx
export default function Button() {
  function handleClick() {
    alert('You clicked me!');
  }

  return (
    <button onClick={handleClick}>
      Click me
    </button>
  );
}
```

event handler functions
- are usually defined inside components
- have names with a `handle` prefix

convention to name event handlers as `handle` followed by event name.

inline event handler in JSX

```jsx
<button onClick={function handleClick() {
  alert('You clicked me!');
}}>

// using an arrow function
<button onClick={() => {
  alert('You clicked me!');
}}>
```

inline event handlers are common for short functions.

**pitfall**

functions passed to event handlers must be passed, not called.


```jsx
// passing a function
<button onClick={handleClick}>

// calling a function (incorrect)
<button onClick={handleClick()}>
```

passing a function as an event handler tells react to remember it and call it when the user clicks the button

passing a function call invokes it immediately during rendering without any clicks. 

> javascript inside `{}` executes right away.

writing inline code the same pitfall is seen

```jsx
// passing
<button onClick={() => alert('...')}>
// calling
<button onClick={alert('...')}>
```
the function is invoked every time the component renders if you pass a function invocation. The function is stored and later invoked by a user interaction e.g if you pass a function definition(declaration)

**reading props in event handlers**

a button that shows an alert with the `message` prop when clicked

```jsx
function AlertButton({ message, children }) {
  return (
    <button onClick={() => alert(message)}>
      {children}
    </button>
  );
}

export default function Toolbar() {
  return (
    <div>
      <AlertButton message="Playing!">
        Play Movie
      </AlertButton>
      <AlertButton message="Uploading!">
        Upload Image
      </AlertButton>
    </div>
  );
}
```

**passing event handlers as props**

parent component specifies a child's event handler.

depending on where you use a `Button` component, you can execute different functions.

```jsx
function Button({ onClick, children }) {
  return (
    <button onClick={onClick}>
      {children}
    </button>
  );
}

function PlayButton({ movieName }) {
  function handlePlayClick() {
    alert(`Playing ${movieName}!`);
  }

  return (
    <Button onClick={handlePlayClick}>
      Play "{movieName}"
    </Button>
  );
}

function UploadButton() {
  return (
    <Button onClick={() => alert('Uploading!')}>
      Upload Image
    </Button>
  );
}

export default function Toolbar() {
  return (
    <div>
      <PlayButton movieName="Kiki's Delivery Service" />
      <UploadButton />
    </div>
  );
}
```

`Toolbar` renders `PlayButton` and `UploadButton`

`PlayButton` passes `handlePlayClick` as `onClick` prop to the `Button` inside

`UploadButton` passes an arrow function as the `onClick` prop to the `Button` inside.

`Button` accepts a prop `onClick` it passes the prop directly to the built-in browser `<button>`

following design systems, is common for components like buttons to contain styling but not specify behavior, behavior is passed down from the parent(s).

**naming event handler props**

built-in html elements like `<button>` only support built-in browser events like `onClick`

create own components and give their event handler props any name.

```jsx
export default function App() {
  return (
    <Toolbar
      onPlayMovie={() => alert('Playing!')}
      onUploadImage={() => alert('Uploading!')}
    />
  );
}

function Toolbar({ onPlayMovie, onUploadImage }) {
  return (
    <div>
      <Button onClick={onPlayMovie}>
        Play Movie
      </Button>
      <Button onClick={onUploadImage}>
        Upload Image
      </Button>
    </div>
  );
}

function Button({ onClick, children }) {
  return (
    <button onClick={onClick}>
      {children}
    </button>
  );
}
```

**event propagation**

event handlers can catch events from any children the component might have.

the event *bubbles* or *propagates* up the tree.

```jsx
export default function Toolbar() {
  return (
    <div className="Toolbar" onClick={() => {
      alert('You clicked on the toolbar!');
    }}>
      <button onClick={() => alert('Playing!')}>
        Play Movie
      </button>
      <button onClick={() => alert('Uploading!')}>
        Upload Image
      </button>
    </div>
  );
}
```

> all events propagate in react except onScroll

**stopping propagation**

event handlers receive an event object as their only argument.

`e` is the common name for the event object.

the event object lets you stop propagating by calling `e.stopPropagation()`

```jsx
function Button({ onClick, children }) {
  return (
    <button onClick={e => {
      e.stopPropagation();
      onClick();
    }}>
      {children}
    </button>
  );
}


export default function Toolbar() {
  return (
    <div className="Toolbar" onClick={() => {
      alert('You clicked on the toolbar!');
    }}>
      <Button onClick={() => alert('Playing!')}>
        Play Movie
      </Button>
      <Button onClick={() => alert('Uploading!')}>
        Upload Image
      </Button>
    </div>
  );
}
```

- react calls `onClick` handler passed to `<button>`
- handler defined in `Button` stops propagation and calls the `onClick` function psased as prop from the `Toolbar` component

**passing handlers as alternative to propagation**

```jsx
function Button({ onClick, children }) {
  return (
    <button onClick={e => {
      e.stopPropagation();
      onClick();
    }}>
      {children}
    </button>
  );
}
```

`<button>` is handling propagation. it could also handle the event while letting the parent component define additional behavior.

this handles propagation in a manual mechanism to have more control when tracing handlers

**prevent default behavior**

some browser events have default behavior associated with them.

`<form>` submit event will reload the whole page 

```jsx
export default function Signup() {
  return (
    <form onSubmit={() => alert('Submitting!')}>
      <input />
      <button>Send</button>
    </form>
  );
}

// call preventDefault on the event
return (
    <form onSubmit={(e) => {
      e.prevventDefault();
      alert('submitting!');
    }}>
      <input />
      <button>Send</button>
    </form>
  );
```

event handlers have side effects, the best place to have side effects actually.

event handlers don't need to be pure.

event handlers are great to change data, in order to change it we need to store it in *state*.

## state: a component's memory

components often change displayed data as a result of an interaction.

typing into a form should update the input field.

clicking next on an image carousel should change the displayed image.

clicking buy puts a product in the shopping cart.

component-specific memory is called state

adding state is done using a hook `useState`

hooks are special functions that let your components use react features.

the `useState` allows to declare a state variable

it takes initial state and return a pair of values, the current state and a state setter function to update it.

```jsx
const [index, setIndex] = useState(0);
const [showMore, setShowMore] = useState(false);
```

regular variables aren't enough

```jsx
export default function Gallery() {
  let index = 0;

  function handleClick() {
    index = index + 1;
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleClick}>
        Next
      </button>
      <h2>
        <i>{sculpture.name} </i> 
        by {sculpture.artist}
      </h2>
      <h3>  
        ({index + 1} of {sculptureList.length})
      </h3>
      <img 
        src={sculpture.url} 
        alt={sculpture.alt}
      />
      <p>
        {sculpture.description}
      </p>
    </>
  );
}
```

`handleClick` event handler is updating a local variable


- local variables don't persist between renders.
- changes to local variables won't trigger renders. React doesn't realize it needs to render the component with new data.

to update data
- retain data between renders
- trigger react to render the component with new data

the `useState` hook provides
- a state variable to retain data
- a state setter function to update the variable to trigger react to re-render

```jsx
import { useState } from 'react';

// replace
let index = 0;

// with
const [index, setIndex] = useState(0);
```

array destructuring is used to read values from an array.

the array returned by `useState` always has two items

```jsx
export default function Gallery() {
  const [index, setIndex] = useState(0);

  function handleClick() {
    setIndex(index + 1);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleClick}>
        Next
      </button>
      <h2>
        <i>{sculpture.name} </i> 
        by {sculpture.artist}
      </h2>
      <h3>  
        ({index + 1} of {sculptureList.length})
      </h3>
      <img 
        src={sculpture.url} 
        alt={sculpture.alt}
      />
      <p>
        {sculpture.description}
      </p>
    </>
  );
}
```

hooks are special functions only available while react is rendering. 

**pitfall**

- hooks can only be called at the top level of components or own hooks.
- can't call hook inside conditions, loops or nested functions
- you use react features at the top of the component in a similar way we import modules at the top level of a script.

**anatomy of useState**

is a convention to name the pair `[something, setSomething]`

only argument `useState` receives is the initial value of the state variable.

everytime the component renders, `useStatae` gives an array containing two values
- state variable
- state setter function

- component renders first time, `index` initial value is 0
- updating state `setIndex(index + 1)` it tells react to remember index is 1 and triggers another render
- component's second render, react still sees `useState(0)` but *remembers* that index is 1

**multiple state variables**

```jsx
export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleNextClick}>
        Next
      </button>
      <h2>
        <i>{sculpture.name} </i> 
        by {sculpture.artist}
      </h2>
      <h3>  
        ({index + 1} of {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? 'Hide' : 'Show'} details
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img 
        src={sculpture.url} 
        alt={sculpture.alt}
      />
    </>
  );
}
```

> hooks rely on a stable call order on every render of the same component

this is possible if you call hooks only at the top level.

internally, react holds an array of state pairs for every component. 

[hooksk in depth](https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e)

**state is isolated and private**

state is local to a component instance.

if you render the same component twice, each copy will have an isolated state.

```jsx
import Gallery from './Gallery.js';

export default function Page() {
  return (
    <div className="Page">
      <Gallery />
      <Gallery />
    </div>
  );
}
```

state is not tied to a particular function call or a scope but its local to the specific place on the screen.

`Page` component doesn't know anything about `Gallery`

> unlike props, state is fully private to the component declaring it

if both galleries should sync their states, child components should be stateless and the state should be added to their closest shared parent.

## render and commit

before components are displayed they must be rendered

the process of requesting and serving UI
- triggering a render
- rendering the component
- commiting to the DOM

**1. trigger a render**

a component renders
- if it's the initial render
- the component's state has been updated (or ancestor)

when the app starts the initial render needs to be triggered.

`createRoot` is called passing the target DOM node where the app will be injected.

then call it's render method taking a component

```jsx
import Image from './Image.js';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'))
root.render(<Image />);

/*  ------------  */

export default function Image() {
  return (
    <img
      src="https://i.imgur.com/ZF6s192.jpg"
      alt="'Floralis Genérica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals"
    />
  );
}
```

the app re-renders when state updates

after the initial render, further re-renders can be triggered by updating state with a `set` function.

updating a component state queues a render.

**2. react renders components**

after triggering the render, react calls components to figure out what to display.

> rendering is react invoking (calling) the components

on initial render react calls the root.

for subsequent renders, react will call the function component whose state update triggered the render.

> process is recursive

if the updated component, returns other component, react will render that component until there are no more nested components.

`Gallery()` and `Image()` are called several times.

```jsx
// index.js
import Gallery from './Gallery.js';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'))
root.render(<Gallery />);

// gallery.js
export default function Gallery() {
  return (
    <section>
      <h1>Inspiring Sculptures</h1>
      <Image />
      <Image />
      <Image />
    </section>
  );
}

function Image() {
  return (
    <img
      src="https://i.imgur.com/ZF6s192.jpg"
      alt="'Floralis Genérica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals"
    />
  );
}
```

- initial render react creates the DOM nodes for `<section>` `<h1>` and `<img>` tags.
- during re-render, react calculates which properties have changed, it won't do anything until the commit phase.

**pitfall**

rendering must always be a pure calculation, functional programming principle

**3. react commits changes to DOM**

after rendering (calling) components, react modifies the DOM.

- initial render, React uses `appendChild()` DOM API to put all the DOM nodes on screen
- for re-renders, React will apply minimal necessary operations to make the DOM match the latest rendering output.

react only changes DOM nodes if there's a difference between renders.

```jsx
export default function Clock({ time }) {
  return (
    <>
      <h1>{time}</h1>
      <input />
    </>
  );
}

```

during commiting changes to DOM react only updates the properties that have changed `{time}` the rest is the same.

**browser paint**

after rendering is done and react updated the DOM, the browser repaints the screen (browser rendering).

use `StrictMode` to find mistakes in components

> react doesn't touch the DOM if the rendering result is the same as the last time

## state as snapshot

state behaves like a snapshot more than regular variables that you can read and write to.

setting state doesn't change the existing variable as that would go against functional programming.

setting state triggers a re-render

**setting state triggers renders**

for an interface to react to an event, the state must be updated.

pressing `send` will `setIsSent(true)` and triggers a re-render

```jsx
import { useState } from 'react';

export default function Form() {
  const [isSent, setIsSent] = useState(false);
  const [message, setMessage] = useState('Hi!');
  if (isSent) {
    return <h1>Your message is on its way!</h1>
  }
  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      setIsSent(true);
      sendMessage(message);
    }}>
      <textarea
        placeholder="Message"
        value={message}
        onChange={e => setMessage(e.target.value)}
      />
      <button type="submit">Send</button>
    </form>
  );
}

function sendMessage(message) {
  // ...
}
```

- `onSubmit` event handler executes
- `setIsSent(true)` queues a new render
- react re-renders

**rendering takes a snapshot in time**

rendering means that react is invoking a component (function).

JSX returned from that function is like a snapshot of the UI in time.

props, event handlers and local variables were calculated usint its state at the time of the render

the returned UI is interactive, it includes logic like event handlers that define what happens in response to certain inputs.

react updates screen to match snapshot and connects the event handlers.

re-rendering a component
- react calls the function again
- function returns a new JSX snapshot
- react updates the screen to match the snapshot

state is not a regular variable that disappears after the function returns.

state lives in react itself.

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 1);
        setNumber(number + 1);
        setNumber(number + 1);
      }}>+3</button>
    </>
  )
}

```

`setNumber(number + 1)` should be called three times adding 3 yet it only increments once per click.

> setting state only changes it for the next render

because `number` in the initial render is 0, the state is set three times to update it once to 1.

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 5);
        alert(number);
      }}>+5</button>
    </>
  )
}

// putting a timer on the alert
return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 5);
        setTimeout(() => {
          alert(number);
        }, 3000);
      }}>+5</button>
    </>
  )

```

a state variable's value never changes within a render even if its event handler's code is asynchronous.

the value of state variables is fixed within a single render

making event handlers less prone to timing mistakes

form sends a message with a 5 seconds delay

- press send, sending hello
- before 5 second delay, value of `to` changes to `bob`

```jsx
import { useState } from 'react';

export default function Form() {
  const [to, setTo] = useState('Alice');
  const [message, setMessage] = useState('Hello');

  function handleSubmit(e) {
    e.preventDefault();
    setTimeout(() => {
      alert(`You said ${message} to ${to}`);
    }, 5000);
  }

  return (
    <form onSubmit={handleSubmit}>
      <label>
        To:{' '}
        <select
          value={to}
          onChange={e => setTo(e.target.value)}>
          <option value="Alice">Alice</option>
          <option value="Bob">Bob</option>
        </select>
      </label>
      <textarea
        placeholder="Message"
        value={message}
        onChange={e => setMessage(e.target.value)}
      />
      <button type="submit">Send</button>
    </form>
  );
}

```

